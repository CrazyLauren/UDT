/*
 * CSafePtr.h
 *
 * Copyright © 2016 Sergey Cherepanov (sergey0311@gmail.com)
 *
 *  Created on: 10.06.2014
 *      Author: Sergey Cherepanov (https://github.com/CrazyLauren/UDT)
 *
 * Distributed under MPL 2.0 (See accompanying file LICENSE.txt or copy at
 * https://www.mozilla.org/en-US/MPL/2.0)
 */ 
#ifndef CSAFEPTR_H_
#define CSAFEPTR_H_

namespace NSHARE
{
template<class T> class  CSafePtr//FIXME см. CSafeData
{
private:
#define AUTO_BLOCKINGS(r,n) CRAII<CMutex> _block##n (*r.get());
#define AUTO_BLOCKING(r) AUTO_BLOCKINGS(r,0)
	typedef CSafePtr<T> type_name;
public:
	typedef T element_type;
	typedef T value_type;
	typedef T * pointer;

	CSafePtr() :
			pFData(new T), pFMutex(new CMutex) //fixme нужен конструктор
	{
	}

	template<class Y>
	explicit CSafePtr(Y * const aP) :
			pFData(aP), pFMutex(new CMutex) // Y must be complete, only read - non block
	{
	}

	template<class Y>
	CSafePtr(CSafePtr<Y> const & aA)
	{
		AUTO_BLOCKING(aA.FMutex)
		pFData(aA.FData), pFMutex(aA.FMutex);
	}
	CSafePtr & operator=(CSafePtr const & aA)
	{
		AUTO_BLOCKINGS(pFMutex, 0);
		AUTO_BLOCKINGS(aA.pFMutex, 1)
		pFData = aA.pFData;
		SHARED_PTR<CMutex> _temp(pFMutex);
		pFMutex = aA.pFMutex;
		return *this;
	}
	template<class Y = T>
	class WAccess
	{
		CSafePtr<Y>& FSafePtr;
		volatile bool FIsLock;
		volatile int* pFCount;
		WAccess<Y>& operator=(WAccess<Y> const& aRhs)
		{
			return *this;
		}
	public:
		WAccess(CSafePtr<Y>& aA) :
				FSafePtr(aA)
		{
			FIsLock = FSafePtr.pFMutex->Lock();
			pFCount = new int;
			*pFCount=1;
		}
		WAccess(WAccess<Y> const& aRhs) :
				FSafePtr(aRhs.FSafePtr)
		{
			FIsLock = aRhs.FIsLock;
			pFCount = aRhs.pFCount;
			++*pFCount;
		}
		~WAccess()
		{
			if (1 == *pFCount)
			{
				delete pFCount;
				if (FIsLock && FSafePtr.pFMutex->Unlock())
				{
				}
			}
			else
			{
				--*pFCount;
			}
		}
		T& operator*()
		{
			return (*FSafePtr.pFData);
		}

		T * operator->() // never throws
		{
			return FSafePtr.pFData.get();
		}
		WAccess<Y> & operator=(Y const & aData)
		{
			*FSafePtr.pFData = aData;
			return *this;
		}
		operator Y &() const
		{
			return *FSafePtr.pFData.get();
		}
	};
	template<class Y = T>
	class RAccess
	{
		CSafePtr<Y> const& FSafePtr;
		volatile bool FIsLock;
		volatile int* pFCount;
		RAccess<Y>& operator=(RAccess<Y> const& aRhs)
		{
			return *this;
		}
	public:

		RAccess(CSafePtr<Y> const& aA) :
				FSafePtr(aA)
		{
			FIsLock = FSafePtr.pFMutex->Lock();
			pFCount = new int;
			*pFCount=1;
		}
		RAccess(RAccess<Y> const& aRhs) :
				FSafePtr(aRhs.FSafePtr)
		{
			FIsLock = aRhs.FIsLock;
			pFCount = aRhs.pFCount;
			++*pFCount;
		}
		~RAccess()
		{
			if (1 == *pFCount)
			{
				delete pFCount;
				if (FIsLock && FSafePtr.pFMutex->Unlock())
				{
				}
			}
			else
			{
				--*pFCount;
			}
		}
		T const& operator*() const // never throws
		{
			return *FSafePtr.pFData;
		}

		T const* operator->() const // never throws
		{
			return get();
		}

		T const * get() const // never throws
		{
			return FSafePtr.pFData.get();
		}
		operator bool() const
		{
			return get();
		}
		operator Y const&() const
		{
			return *get();
		}
	};
	WAccess<T> operator*()
	{
		return WAccess<T>(*this);
	}
	RAccess<T> operator*() const //only read
	{
		return RAccess<T>(*this);
	}

	WAccess<T> operator->()
	{
		return WAccess<T>(*this);
	}
	RAccess<T> const operator->() const
	{
		return *this;
	}
	T const * get() const
	{
		return pFData.get();
	}
	operator bool() const
	{
		bool _val = RAccess<T>(*this);
		return _val;
	}
	typedef RAccess<T> const RAtomic;
	typedef WAccess<T> WAtomic;
	RAtomic MGetAtomic() const
	{
		return *this;
	}
	WAtomic MGetAtomic()
	{
		return *this;
	}
private:
	SHARED_PTR<T> pFData; // contained pointer
	mutable SHARED_PTR<CMutex> pFMutex; // blocker
};
} //namespace USHARE
#endif /* CSAFEPTR_H_ */
