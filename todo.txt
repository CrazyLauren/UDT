1. Наследование
2. Проверить группы (тест)
2.1 Тест автоматический
	.1 Управление тестом осушествлять через ядро
	.2 Логика работы теста
		.1 Издатели подписываются на соотвествующее управляющее сообщение подписчика
		.2 Подписчик подписывается на сообщение "ближнего" издателя с флагом E_NEAREST
		.3 Команду eFINISH отсылают "ближнему" издателю
			.1 Проверяет переподключение к новому "ближнему" издателю
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.4 Команду eFINISH отсылают "дальниму" издателю
			.1 Проверяет неизменность состояния подписки
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.5 Подключаем более "ближнего" издателя 
			.1 Проверяет переподключение к новому "ближнему" издателю
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.6 Завершаем работу
	3. Повторяется тест .2 для инвертированных групп
3. Реализовать возможность моделирования
3.1 Добавить в SHARE rand
3.2 Сделать диспетчер
3.3 Подумать об упрощении работы с библиотками преобразования данных (Парсеров)
4. Изменить API customer 
	.1 Придумать способ обеспечения соответсвия enum в customer и его собрата в реализации
	.2 Упростить API выделения памяти, сделать аналог malloc и free(может сделать соотвествующий allocator)?
		.1 После выделения памяти нужно знать эллокатор которым он был выделен, иначе возникнет ошибка
	.3 Продумать и прокомментировать API
		.1 Добавить отдельный тип data_t содержащий FBuffer, FHeaderBegin, FBegin, FEnd
		.2 FEnd Должен указывать на конец сообщения, а не буфера.  Выражение не верно: _raw_args.FMessage.FEnd =	reinterpret_cast<const uint8_t*>(&_raw_args.FMessage.FBuffer.back());
	.4 Добавить stream"ы
	
5. В SHARE Socket добавить событь closed и opened