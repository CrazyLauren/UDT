1. Наследование
+2. Проверить группы (тест)
+2.1 Тест автоматический
	.1 Управление тестом осушествлять через ядро
	.2 Логика работы теста
		.1 Издатели подписываются на соотвествующее управляющее сообщение подписчика
		.2 Подписчик подписывается на сообщение "ближнего" издателя с флагом E_NEAREST
		.3 Команду eFINISH отсылают "ближнему" издателю
			.1 Проверяет переподключение к новому "ближнему" издателю
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.4 Команду eFINISH отсылают "дальниму" издателю
			.1 Проверяет неизменность состояния подписки
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.5 Подключаем более "ближнего" издателя 
			.1 Проверяет переподключение к новому "ближнему" издателю
			.2 Отсылаём комнду eSEND проверяем правлильность пересылки
		.6 Завершаем работу
	3. Повторяется тест .2 для инвертированных групп
3. Реализовать возможность моделирования
	.1 Добавить инфу по используемому RTC
	.2 Добавить возможность для настройки RTC 
		.1 Прокинуть сообщения между ядром и программой
		.2 Выделить общую память для хранению текущего времени
			.1 Создаём новую shared_memory для этих целей
				.1 Заодно может отрефлакторим
			.2 Создаём там mutex и condvar
			.3 Создаём два поле для хранения времени 
				a) текущее модельное время
				b) время когда было записано время (HW время)
			.4 При обновлении времени сохраняем оба поля
			.5 При считывании:
				a) В режиме времени от ядра 
					считваем текущее и прибовляем HW разницу
				б) В режиме модельном считываем текущее время		
	.3 Как обновлять текущее время?
		.1 В ядре linux считывается счётчик из памяти и добавляется разница между каким временем?
		.2 Основной вопрос как хранить время?
		.3 Обновлять его по событию долго		
	.4 Тесты можно взять из netbsd\lib'libc\sys\t_clock_gettime
	.5 Основной файл связанный со врменем kern_tc.c
	.6 Разделить customer на два состовляющих RTC and IO
	.7 Подумать об упрощении работы с библиотками преобразования данных (Парсеров)
	.8 Как моделировать КП он ведь работает асинхронно
		.1 Так как он работаёт только по приёму сообщений то он ну ожидает следующего 
			момента времени, точнее оно у него всегда максимальное, таким образом
			при работе двух КП как сдвигать время?
	.9 RTC создаёт ядро 
		.1 При подключении оно рассылает список доступных RTC
		.2 RTC регистрируются
	.10 Добавить метод физичное время, т.е. время не может бежать быстрее
		чем реальное время
		
4. Изменить API customer 
	+.1 Придумать способ обеспечения соответсвия enum в customer и его собрата в реализации
	.2 Упростить API выделения памяти, сделать аналог malloc и free(может сделать соотвествующий allocator)?
		.1 После выделения памяти нужно знать эллокатор которым он был выделен, иначе возникнет ошибка
	.3 Продумать и прокомментировать API
		+.1 Добавить отдельный тип data_t содержащий FBuffer, FHeaderBegin, FBegin, FEnd
		.2 FEnd Должен указывать на конец сообщения, а не буфера.  Выражение не верно: _raw_args.FMessage.FEnd =	reinterpret_cast<const uint8_t*>(&_raw_args.FMessage.FBuffer.back());
	+.4 Добавить stream"ы
	+.5 MWaitForEvent проверить
	.6 Разобраться с размерностью типов данных которые возвращаются функциями,там везде преобразование от uint32_t к int
	
5. Модернизация SHARE
	.1 В SHARE Socket добавить событие closed и opened
	.2 Поравить логи для новой библиотеки log4cplus
		+ 5.3 Добавить в SHARE rand
	.4 Разобраться с deftype
		.1 Сделать его конфигурируемым для MINGW
		.2 Препроцессора __cplusplus для комплиятора msvc
	.5 Парсер командной строки
		.1 TCLAP является иерархическим. Т.е. необходимо убрать init_trace функцию
	.6 TCP
		.1 Отрефлакторить TCP Client			
		.2 Отрефлакторить TCP Server
		.3 Добавить возможность приёма сообщений сразу от не скольких клиентов в TCP Client
			.1 Поправить CTcpClientMainChannel в соотвествии с новой логикой
		.4 Добавить в фабрирку mutex доступа
		

+6. Test скорости
7. Привести в порядок примеры работы
+9. Проверить новый конструктор required_header_t
+10. Example_customer переменовать в defualt_config
+11. Kerne.cfg переменовать в defualt_kernel
12. Авто поиск ядер по ping пакетам
	12.1 Информация по ядрам которые были добавлены через авто поисе должны автоматически удаляться при потере соединения
		CKernelIOByTCPClient::MAddClient
13. Продокументировать SHARE Sockets и привести код в порядок
14. Наследование
	+.1 Разработать тест
	+.2 Проблема с получением списка callback для вызова функций
	+.3 Добавить тест на правильность подписи callback в зависимости от 
	+.4 Контроль версии для сообщений
	того на что подписываемся (если подписываемся на базовый класс то также должны подписать на все его потомки)
	.5 Указать правильно конец сообщения.
15. Добавить FindUDT.cmake