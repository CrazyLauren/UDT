// This is a personal academic project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
{% import "base_macros.tmpl" as common %}
{% set file_name = 'subscriber_test_' + name | lower %}
{{ common.add_file_secription(file_name+'.cpp') }}
{% autoescape false %}
#include <deftype>
#include <customer.h>

#include "{{ common.get_namespace(name) }}_test_generator.h"
#include "{{ file_name }}.h"

using namespace NUDT;

using namespace {{ common.get_namespace(name) }};
using namespace {{ common.get_namespace(name) }}::test;
namespace {{ common.get_namespace(name) }}
{
namespace test
{
bool subscriber_test(int argc, char const*argv[])
{
	///1) Initialization library by initialize_library()

	int const _rval = initialize_library(argc, argv);
	if (_rval != 0)
		return false;

	///2) sending something by send_messages()
	bool _is=doing_tests();

	CCustomer::sMGetInstance().MClose();

	///3) wait for finished by NUDT::CCustomer::MJoin()
	CCustomer::sMGetInstance().MJoin();
	return _is;
}

int initialize_library(int argc, char const*argv[])
{

	/*! Algorithm: \n
	 * 1. Initialize UDT library
	 */
	const int _val = CCustomer::sMInit(argc, argv, get_id().c_str(),
			NSHARE::version_t({{ version.major }}, {{ version.minor }}, {{ version.revision }}));
	if (_val != 0)
	{
        LOG(ERROR)<< "Cannot initialize library as " << _val ;
		return EXIT_FAILURE;
	}

	/*! 2.
     *  3. Subscribe to the event #NUDT::CCustomer::EVENT_CONNECTED to when the UDT library
	 *  will be connected to the kernel, the function
	 *  #event_connect_handler is called.
	 */
	CCustomer::sMGetInstance() += event_handler_info_t(
			CCustomer::EVENT_CONNECTED, event_connect_handler);
	CCustomer::sMGetInstance() += event_handler_info_t(
			CCustomer::EVENT_DISCONNECTED, event_disconnect_handler);

	/*! 4. Subscribe to the event #NUDT::CCustomer::EVENT_RECEIVER_SUBSCRIBE to
	 * when some program will start receiving data from me. The function
	 * #event_new_receiver is called.
	 */
	CCustomer::sMGetInstance() += event_handler_info_t(
			CCustomer::EVENT_RECEIVER_SUBSCRIBE, event_new_receiver);

	/*! 5. Subscribe to the event #NUDT::CCustomer::EVENT_FAILED_SEND to
	 *  when the sent packet is not delivered by UDT (usually It's happened when The UDT system
	 *  is overloaded or The receiver has been disconnected). The function
	 *  #event_fail_sent_handler is called.*/
	CCustomer::sMGetInstance() += event_handler_info_t(
			CCustomer::EVENT_FAILED_SEND, event_fail_sent_handler);

	/*! 5.1 Subscribe to the event #NUDT::CCustomer::EVENT_RECEIVER_UNSUBSCRIBE to
	 * when some program will finished to receive data from me. The function
	 * #event_remove_receiver is called.
	 */
	CCustomer::sMGetInstance() += event_handler_info_t(
			CCustomer::EVENT_RECEIVER_UNSUBSCRIBE, event_remove_receiver);

	/*! 6. Starting the 'main loop' of the UDT library */
	CCustomer::sMGetInstance().MOpen();

	/*! 8. Wait for me to connect to the kernel*/
	CCustomer::sMGetInstance().MWaitForEvent(CCustomer::EVENT_CONNECTED);

	return 0;
}
}
}
{% endautoescape %}