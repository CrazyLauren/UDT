{% set file_name = 'protocol_' + name | lower+ '_matlab_serialize' %}
{% import "base_macros.tmpl" as common %}
{% import "message_macros.tmpl" as fm %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape False %}
#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

#include <deftype>
#include <{{ common.get_namespace(name) }}.h>

#include <SHARE/matlab_serialize.h>

namespace NSHARE
{
namespace matlab
{
using namespace {{ common.get_namespace(name) }};
{% macro gen_check_for(aMsg, aIfFirst = False) %}
   {% for field in aMsg.___fields |fields(True) if field.id %}
        {% if not loop.first  or not aIfFirst %}
        else
        {% endif %}
            if ( !_is_{{ field.id }} && strcmp("{{ field.id }}", fieldName ) == 0 )
        {
            _is_{{ field.id }} = true;
        {% set _type = field.TypeOfLogicalType if field | is_dynamic else field.type %}
        {% if field | is_array or field | is_dynamic %}
            DCHECK_GE(_dims, 2);
            DCHECK_EQ(_rows*_cols, _elems);
            DCHECK(_rows == 1 || _cols == 1);
            if ( _dims != 2
                || _rows*_cols != _elems
                || (_rows != 1 && _cols != 1)
                )
            {
                if(_dims != 2 || (_rows != 1 && _cols != 1))
                    mexWarnMsgIdAndTxt("{{ name }}:InvalidDimsInField",
                        "Invalid array dims in field %s",
                        fieldName);

                if(_rows*_cols != _elems)
                    mexWarnMsgIdAndTxt("{{ name }}:InvalidArrayLenInField",
                        "Invalid array len in field %s",
                        fieldName);

                continue;
            }
            {% if  field | is_complex %}
                {% if field | is_dynamic %}

            _tval.{{ field.id }}.resize(_elems);
            {{ _type }}* _to = &_tval.{{ field.id }}.front();
            size_t const _size = _elems;
                {% else %}

            {{ _type }}* _to = ({{ _type }}*) _tval.{{ field.id }};
            size_t const _own_size = sizeof(_tval.{{ field.id }})/sizeof(_tval.{{ field.id }}[0]);
            DCHECK_EQ(_own_size, _elems);
            if(_own_size != _elems)
                mexWarnMsgIdAndTxt("{{ name }}:ArrayIsInvalid",
                    "The length of array is invalid. Field %s",
                    fieldName);

            using namespace std;
            size_t const _size = min(_elems, _own_size);
                {% endif %}

            for(size_t i =0; i < _size;
                ++i,
                ++_to
                )
                {
                    _to->makeZero();
                    if(!deserialize<{{ _type }}>(_to, fieldContent, 1,  i))
                    {
                        mexErrMsgIdAndTxt("{{ name }}:ConvertingError", "Error is occurred for %s",
                            fieldName);
                        _is = false;
                    }
                }
            {% else %}
            if( static_cast<mxClassID>(matlab_code_t<{{ _type }}>::value) != _class )
            {
                DCHECK(false);
                mexWarnMsgIdAndTxt("{{ name }}:InvalidDataType",
                                    "Invalid data type in field %s",
                                    fieldName);
                continue;
            }

                {% if field | is_dynamic %}
            _tval.{{ field.id }}.resize(_elems);
            {{ _type }}* _to = &_tval.{{ field.id }}.front();
            size_t const _size = _tval.{{ field.id }}.size();
                {% else %}
            {{ _type }}* _to = ({{ _type }}*) _tval.{{ field.id }};
            size_t const _own_size = sizeof(_tval.{{ field.id }})/sizeof(_tval.{{ field.id }}[0]);
            DCHECK_EQ(_own_size, _elems);
            if(_own_size != _elems)
                mexWarnMsgIdAndTxt("{{ name }}:ArrayIsInvalid",
                    "The length of array is invalid. Field %s",
                    fieldName);

            using namespace std;
            size_t const _size = min(_elems, _own_size);
                {% endif %}
            if(!deserialize(_to,  fieldContent, _size, 0))
            {
                mexErrMsgIdAndTxt("{{ name }}:ConvertingError", "Error is occurred for %s",
                    fieldName);
                _is = false;
            }
            {% endif %}
        {% elif field | is_complex %}
            if(!deserialize(&_tval.{{ field.id }}, fieldContent, 1,  0))
            {
                mexErrMsgIdAndTxt("{{ name }}:ConvertingError", "Error is occurred for %s",
                    fieldName);
                _is = false;
            }
        {% elif field.bits > 0 %}
            {
                {{ _type }} _val;
                if(!deserialize(&_val, fieldContent, 1,  0))
                {
                    mexErrMsgIdAndTxt("{{ name }}:ConvertingError", "Error is occurred for %s",
                            fieldName);
                    _is = false;
                }else
                {
                    _tval.{{ field.id }} = _val;
                    if(_val != _tval.{{ field.id }})
                        mexWarnMsgIdAndTxt("{{ name }}:Overflow", "Bit field overflow see protcol. Field %s",
                        fieldName);
                }
            }
        {% else %}
            if(!deserialize(&_tval.{{ field.id }}, fieldContent, 1,   0))
            {
                mexErrMsgIdAndTxt("{{ name }}:ConvertingError", "Error is occurred for %s",
                    fieldName);
                _is = false;
            }
        {% endif %}
        }
    {% endfor %}
{% endmacro %}

{% macro serialize_matlab_field(aField) %}
    {%if aField | is_array or aField | is_dynamic %}
        {% set _array_len = aField.array_len if aField | is_array else '_object.'+aField.id+'.size()' %}
        {% set _array_ptr = '_object.'+ aField.id if aField | is_array else '_object.'+aField.id+'.empty()?NULL: &_object.'+aField.id+'.front()' %}
        {% set _type = aField.type if aField | is_array else aField.TypeOfLogicalType %}
    mxSetFieldByNumber(_rval, aArrayId, (int)aStartAddr++,  serialize({{ _array_ptr }}, {{ _array_len}}) );
    {% else %}
    mxSetFieldByNumber(_rval, aArrayId, (int)aStartAddr++,  serialize(_object.{{ aField.id }}) );
    {% endif %}
{% endmacro %}
{% macro generate_serialize_matlab_functions(aMsg, aParentArray) %}

{% set aParent =  aParentArray[0] if aParentArray else None %}
{% set dynamic_msg = true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
{% set dynamic_parent_msg = true if parent_name and '___type' in aParent and aParent.___type == 'dynamic' %}
{% set struct_name =  aMsg.___name+'_t' %}
{% set parent_name =  aParent.___name+'_t' if aParent else ''  %}
{% set has_dynamic_child =  aMsg.___has_dynamic_child if '___has_dynamic_child' in aMsg else False %}
template<>
inline mxArray* allocate_memory<{{ struct_name }}>(size_t aArraySize )
{
    if(aArraySize == 0 )
        return NULL;
    mwSize dims[2] = {1, aArraySize};
    const char* field_names[
        {{ aMsg.___fields |fields(True) |length }}
        {% if aParentArray %}
            {% for _parent in aParentArray |reverse %}
                + {{ _parent.___fields | fields(True) |length }}
            {% endfor %}
        {% endif %}
    ];
    size_t const _field_number = sizeof(field_names) / sizeof(*field_names);
    size_t _addr = 0;

    {% if aParentArray %}
        {% for _parent in aParentArray |reverse %}
            {% for field in _parent.___fields |fields(True) if field.id %}
    field_names[_addr++] = "{{ field.id }}";
            {% endfor %}
        {% endfor %}
    {% endif %}

    {% for field in aMsg.___fields |fields(True) if field.id %}
    field_names[_addr++] = "{{ field.id }}";
    {% endfor %}

    DCHECK_EQ(_addr, _field_number);
    if(_addr != _field_number)
    {
        mexWarnMsgIdAndTxt("{{ name }}:invalidFieldSize", "The number of fields");
        return NULL;
    }

    mxArray *var = mxCreateStructArray(2, dims, _field_number, field_names);

    return var;
}

template<>
inline mxArray* serialize<{{ struct_name }}>({{ struct_name }} const* aObject, size_t aArraySize)
{
    mxArray * _rval = allocate_memory<{{ struct_name }}>(aArraySize);
    if(_rval != NULL)
    for(unsigned aArrayId = 0; aArrayId<aArraySize ; ++aArrayId)
    {
        size_t aStartAddr = 0;
        {{ struct_name }} const& _object(aObject[aArrayId]);
        {% if aParentArray %}
            {% for _parent in aParentArray |reverse %}
                {% for field in _parent.___fields |fields(True) if field.id %}
                    {{ serialize_matlab_field(field) }}
                {% endfor %}
            {% endfor %}
        {% endif %}
        {% for field in aMsg.___fields |fields(True) if field.id %}
            {{ serialize_matlab_field(field) }}
        {% endfor %}
    }
    return _rval;
}

template<>
inline mxArray* serialize<{{ struct_name }}>({{ struct_name }} const& aObject)
{
    return serialize(&aObject);
}
template<>
inline bool deserialize<{{ struct_name }}>({{ struct_name }} *aTo,
                                    mxArray const* aObject, size_t aArraySize, size_t aArrayIndex)
{
    if(aTo == NULL)
        return false;

    DCHECK_EQ(aArraySize, 1);//@fixme handle array
    bool _is = true;
    for(unsigned aArrayId = 0; aArrayId < aArraySize && _is ; ++aArrayId)
    {
    {{ struct_name }}& _tval(aTo[aArrayId]);
    _tval.makeZero();

    {% for field in aMsg.___fields |fields(True) if field.id %}
    bool _is_{{ field.id }} = false;
    {% endfor %}
    {% if aParentArray %}
        {% for _parent in aParentArray |reverse %}
            {% for field in _parent.___fields |fields(True) if field.id %}
    bool _is_{{ field.id }} = false;
            {% endfor %}
        {% endfor %}
    {% endif %}

    size_t const _field_num (mxGetNumberOfFields(aObject));
    for (size_t i = 0; i < _field_num; ++i)
    {
        const char* fieldName = mxGetFieldNameByNumber(aObject, (int)i);
        mxArray* fieldContent = mxGetFieldByNumber(aObject, aArrayIndex, (int)i);

        if (!fieldName)
        {
            mexWarnMsgIdAndTxt("{{ name }}:NoNameInField", "No field name in structure ");
            continue;
        }
        if (!fieldContent)
        {
            mexWarnMsgIdAndTxt("{{ name }}:NoDataInField", "No data in field %s", fieldName);
            continue;
        }

        size_t const _rows = static_cast<size_t>(mxGetN(fieldContent));
        size_t const _cols = static_cast<size_t>(mxGetM(fieldContent));
        size_t const _elems = static_cast<size_t>(mxGetNumberOfElements(fieldContent));
        size_t const _dims = static_cast<size_t>(mxGetNumberOfDimensions(fieldContent));
        mxClassID const _class = mxGetClassID(fieldContent);

        {% if aParentArray %}
            {% for _parent in aParentArray | reverse %}
                {{ gen_check_for(_parent, loop.first) }}
            {% endfor %}
        {% endif %}
        {% set _is_first = True if not aParentArray or aParentArray|length == 0 else False %}
        {{ gen_check_for(aMsg, _is_first) }}
        else
        {
            DCHECK(false);
            mexWarnMsgIdAndTxt("{{ name }}:NoFieldInProtocol",
                "Field isn't exist in protocol %s", fieldName);
        }
    }
    }
    return _is;
}
{% endmacro %}

{% for val in types if not types[val].standard and '___fields' in  types[val] %}

{{ generate_serialize_matlab_functions(types[val]) }}

{% endfor %}

{{ generate_serialize_matlab_functions(header) }}

{% for msg in messages-%}
    {{ generate_serialize_matlab_functions(msg,msg.___parent) }}
{% endfor %}

}//namespace matlab
}//namespace {{ common.get_namespace(name) }}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}
