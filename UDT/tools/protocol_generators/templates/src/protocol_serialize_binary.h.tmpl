{% set file_name = 'protocol_' + name | lower + '_serialize_binary' %}
{% import "base_macros.tmpl" as common %}
{% import "message_macros.tmpl" as fm %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape false %}

#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

#include <{{ name | upper }}/config/config.h>

#include "{{ common.get_namespace(name) }}.h"

{% set attribute_packed = name|upper+'_ATTRIBUTE_PACKED'%}
{%  set struct_header_name =  header.___name+'_t' -%}

namespace {{ common.get_namespace(name) }}
{

#ifndef SERIALIZE_DYNAMIC_MESSAGE_TEMPLATE_IS_DEFINED
#  define SERIALIZE_DYNAMIC_MESSAGE_TEMPLATE_IS_DEFINED

/*! \brief Serialize type T
 *
 * The Serialized data to byte.
 *
 * \param aObject Object
 * \param aTo To buffer
 * \param aAllocator Allocator type
 * \return Serialized object
 * \tparam T Serialized object type
 * \tparam TContainer container type (for example std::vector)
 *  @{
 */
template <typename TContainer, typename T>
inline TContainer& serialize_binary(TContainer& aTo,T const& aObject);
template <typename T>
inline char* serialize_binary(char* aTo,unsigned aMaxSize,T const& aObject);

/// @}

/*! \brief Deserialize type T
 *
 * Deserialize object
 *
 * @param aBuf Serialized data
 * @param aTo deserialize to
 * @return Deserialized object
 * @tparam T Deserialized type
 * @tparam TContainer container type (for example std::vector)
 * \note  The method has to be specialized and "extern" for every external types.
 * @{
 */
template<typename T,typename TContainer>
inline T deserialize_binary(TContainer const& aBuf);
template<typename T,typename TContainer>
inline T& deserialize_binary(T& aTo, TContainer const& aBuf);
template<typename T>
inline T& deserialize_binary(T& aTo, char const* aBegin,
    char const* aEnd);
/*! @}*/

//----------------------------------------
// Implementation
//----------------------------------------

#endif //#ifndef SERIALIZE_DYNAMIC_MESSAGE_TEMPLATE_IS_DEFINED
namespace impl
{
/*! \brief Puts dynamic data to buffer
 *
 * @param aObject Object
 * @param aHeader Pointer to message
 * @param aTo Pointer to buffer
 * @return Pointer to next empty byte
 * @tparam T Object type
 * @tparam Tdyanmic Serialized type
 * \note  The size of buffer has to be requirement to put data
 * @{
 */
template<class Tdyanmic ,class T>
char* serialize_fields(char *aTo, unsigned aMaxSize,
        Tdyanmic* aHeader,T const & aObject );
template<class Tdyanmic ,class T>
char const* deserialize_fields(T& aTo,
        Tdyanmic const& aObject, char const* aPtr );
///@}
}//namespace impl

template<typename T>
inline T& deserialize_binary(T& aTo, char const* aBegin,
    char const* aEnd)
{
    unsigned const _buf_size = aEnd-aBegin;
    unsigned const _size = get_full_size<T>(aTo);
    DCHECK_GE(_size,_buf_size);
    if( _size >= _buf_size )
    {
        T const& _val = *reinterpret_cast<T const*>(aBegin);
        aTo = _val;
    }
    return aTo;
}
template<typename T,typename TContainer>
inline T& deserialize_binary(T& aTo, TContainer const& aBuf)
{
    unsigned const _buf_size = aBuf.size()*sizeof(typename TContainer::value_type);
    return deserialize_binary<T>(aTo,(char const*)&aBuf.front(),
                (char const*)&aBuf.front() + _buf_size);
}
template<typename T,typename TContainer>
inline T deserialize_binary(TContainer const& aBuf)
{
    T _rval;
    deserialize_binary<T,TContainer>(_rval, aBuf);
    return _rval;
}
template<typename T>
inline char* serialize_binary(char* aTo,unsigned aMaxSize,T const& aObject)
{
    if(aMaxSize >= sizeof(T))
    {
       T* _p = new( aTo) T(aObject);
        fill_header<T>( _p );
        DCHECK(is_valid<T>(*_p));
        return  aTo + sizeof(T);
    }
    return NULL;
}
template<typename TContainer, typename T>
inline TContainer& serialize_binary(TContainer& aTo, T const& aObject)
{
    unsigned const _own_size = aTo.size();
    unsigned const _first = _own_size * sizeof(typename TContainer::value_type);
    unsigned const _size = get_full_size<T>(aObject);
    aTo.resize( _own_size//
                    + _size / sizeof(typename TContainer::value_type) // if container value size more 1 byte
                    + _size % sizeof(typename TContainer::value_type) == 0 ? 0:1 // if not multiple ratio
                    );

    char* const _begin = (char *)&(aTo.front()) + _first;
    char* const _p=serialize_binary<T>(_begin,_size,aObject);
    if(_p == NULL )
        aTo.resize(_own_size);
    else
        DCHECK_EQ(_size, (_p-_begin));
    return aTo;
}
{% macro generate_serialize_message(aMsg, aParent) %}

{% set struct_name =  aMsg.___name+'_t' %}
{% set parent_name =  aParent.___name+'_t' if aParent else '' %}
{% set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
{% set dynamic_parent_msg=true if parent_name and '___type' in aParent and aParent.___type == 'dynamic' %}
{% set paret_dynamic_name =  aParent.___name+'_dynamic_t' if dynamic_parent_msg else '' %}
{% set dynamic_fields = aMsg | logical_type("dynamic array",True) %}

{% if dynamic_msg %}
{%  set struct_name_dyanamic =  aMsg.___name+'_dynamic_t' %}
{%  set inherent_t = paret_dynamic_name if paret_dynamic_name else parent_name %}
/*!\brief Struct for convenient struct to serialize dynamic message
 *
 *   {{ aMsg.___description }}
 */
{{ attribute_packed }}(
struct {{ struct_name_dyanamic}}
    {% if paret_dynamic_name %}
    : {{ paret_dynamic_name}}
    {% elif parent_name %}
    : {{ parent_name}}
    {% endif %}
{
    {{ fm.add_constants(aMsg,aParent) }}
    {{ fm.append_fields(aMsg.___fields) }}
    {{ fm.append_reserv(aMsg) }}

    /** Constructs object and copy
    *   only non dynamic data.
    *
    *   @param aData - The message
    */
    {{ struct_name_dyanamic }}({{ struct_name }} const& aData)
        {% if paret_dynamic_name %}
        : {{ paret_dynamic_name}}(aData)
        {% elif parent_name %}
        : {{ parent_name}}(aData)
        {% endif %}
    {
        {% for field in aMsg.___fields %}
            {% if  'LogicalType' in field
                                    and field.LogicalType == "dynamic array" %}
        {{field.id}} = 0;
            {% elif 'array_len' in field and field.array_len  > 0 %}
        for (unsigned i = 0; i < sizeof(aData.{{ field.id }})/sizeof(aData.{{ field.id }}[0]); ++i)
        {
	        {{field.id}}[i] = aData.{{field.id}}[i];
        }
            {% else %}
        {{field.id}} = aData.{{field.id}};
            {% endif %}
        {% endfor %}
    }

    /** Copies all fields to message included dynamic
    *
    * @param aData Copy to
    */
    void MTo({{ struct_name }}& aData) const
    {
        {% if paret_dynamic_name %}
        {{ paret_dynamic_name}}::MTo(aData);
        {% elif parent_name %}
        aData.{{ parent_name }}::operator=(*static_cast<{{ parent_name}} const*>(this));
        {% endif %}

        {% for field in aMsg.___fields if  'LogicalType' in field
                                    and field.LogicalType != "dynamic array" %}
            {% if 'array_len' in field and field.array_len  > 0 %}
        for (unsigned i = 0; i < sizeof(aData.{{ field.id }})/sizeof(aData.{{ field.id }}[0]); ++i)
        {
	        aData.{{field.id}}[i] = {{field.id}}[i];
        }
            {% else %}
        aData.{{field.id}} = {{field.id}};
            {% endif %}
        {% endfor %}
    }
});
#if (__cplusplus>= 201103L) || (_MSC_VER >= 1800)
    static_assert(sizeof({{ struct_name_dyanamic }}) == {{ struct_name }}::SIZE_FULL,
                    "invalid size of message {{ aMsg.___name }}");
#elif defined(COMPILE_ASSERT)
    COMPILE_ASSERT(sizeof({{ struct_name_dyanamic }}) == {{ struct_name }}::SIZE_FULL,
        InvalidSizeOfMessage_dynamic_{{ aMsg.___name }});
#endif
namespace impl{
/*! \brief Gets size of serialized {{ aMsg.___name }} dynamic data
 *
 * @param aVal Object
 * @return Size of dynamic data
 * @tparam T Object type
 */
template<>
unsigned get_full_size_dynamic<{{ struct_name_dyanamic}}>({{ struct_name_dyanamic}} const & aVal )
{
    unsigned _size = 0;

    {% if paret_dynamic_name %}
    _size += get_full_size_dynamic<{{ paret_dynamic_name}}>(
            static_cast<{{ paret_dynamic_name}} const&>(aVal)
            );
    {% endif %}

    {% for field in aMsg | logical_type(["dynamic array"],True) %}
    _size += sizeof({{ struct_name}}::{{field.id}}_dynamic_t::value_type)
            * aVal.{{field.id}};
    {% endfor %}
    return _size;
}
template<>
char* serialize_fields<{{ struct_name_dyanamic}}, {{ struct_name}}>
    (char* aTo, unsigned aMaxSize, {{ struct_name_dyanamic}}* aHeader,
    {{ struct_name}} const & aObject )
{
    {% if paret_dynamic_name %}
    char* const _begin_parent = aTo;
    aTo = impl::serialize_fields<{{ paret_dynamic_name}},
            {{ parent_name }}>(aTo, aMaxSize, aHeader, aObject);
    if( aTo == NULL )
        return NULL;
    aMaxSize -= aTo - _begin_parent;
    {% endif %}
#ifndef NDEBUG
    int _order_prev = std::numeric_limits<int>::min();
#endif
       {% for field in dynamic_fields|sort(attribute='DynamicOrder') %}
    {
        typedef {{ struct_name}}::{{field.id}}_dynamic_t::value_type _value_{{field.id}}_t;
        typedef _value_{{field.id}}_t* _ptr_{{field.id}}_t;

#ifndef NDEBUG
        DCHECK_LE(_order_prev, {{ struct_name}}::DYNAMIC_ORDER_OF_{{ field.id|upper }});
        _order_prev = {{ struct_name}}::DYNAMIC_ORDER_OF_{{ field.id|upper }};
#endif
        unsigned const _{{ field.id }}_len = aObject.{{ field.id }}.size();
        aHeader->{{ field.id }} = _{{ field.id }}_len;
        unsigned const _{{ field.id }}_len_byte = _{{ field.id }}_len *
           sizeof(_value_{{field.id}}_t);

        if(_{{ field.id }}_len_byte > aMaxSize)
           return NULL;

        _ptr_{{field.id}}_t const _begin = (_ptr_{{field.id}}_t) aTo;
        _ptr_{{field.id}}_t  _to = _begin;

        for (unsigned i = 0; i < _{{ field.id }}_len; ++i)
        {
                *(_to++) = aObject.{{ field.id }}[i];
        }
        DCHECK_EQ(_{{ field.id }}_len,_to-_begin);

        aTo += _{{ field.id }}_len_byte;
        DCHECK_EQ(aTo,(char*)_to);
    }
        {% endfor %}
    return aTo;
}
template<>
char const* deserialize_fields<{{ struct_name_dyanamic}}, {{ struct_name}}>
    ({{ struct_name}}& aTo, {{ struct_name_dyanamic}} const& aObject,
    char const* aPtr )
{
    {% if paret_dynamic_name %}
    aPtr = impl::deserialize_fields<{{ paret_dynamic_name}}, {{ parent_name }}>(aTo, aObject, aPtr);
    {% endif %}

#ifndef NDEBUG
    int _order_prev = std::numeric_limits<int>::min();
#endif
       {% for field in dynamic_fields|sort(attribute='DynamicOrder') %}
    {
#ifndef NDEBUG
        DCHECK_LE(_order_prev, {{ struct_name}}::DYNAMIC_ORDER_OF_{{ field.id|upper }});
        _order_prev = {{ struct_name}}::DYNAMIC_ORDER_OF_{{ field.id|upper }};
#endif
        unsigned const _{{ field.id }}_len = aObject.{{ field.id }};

        {{ struct_name}}::{{field.id}}_dynamic_t::value_type const* const _begin =
                        ({{ struct_name}}::{{field.id}}_dynamic_t::value_type*) aPtr;
        {{ struct_name}}::{{field.id}}_dynamic_t::value_type const* _from = _begin;

        aTo.{{field.id}}.resize(_{{ field.id }}_len);

        for (unsigned i = 0; i < _{{ field.id }}_len; ++i)
        {
            aTo.{{ field.id }}[i]=*(_from++);
        }
        DCHECK_EQ(_{{ field.id }}_len, _from-_begin);
        aPtr += _{{ field.id }}_len
           * sizeof({{ struct_name}}::{{field.id}}_dynamic_t::value_type);
        DCHECK_EQ(aPtr,(char const*)_from);
    }
    {% endfor %}
    return aPtr;
}

}
template<>
inline char* serialize_binary<{{ struct_name }}>(char* aTo,unsigned aMaxSize,
    {{ struct_name }} const& aObject)
{
    char* const _begin = aTo;
    if( sizeof({{ struct_name_dyanamic}}) > aMaxSize )
    {
        return  NULL;
    }
    {{ struct_name_dyanamic}}* const _head_ptr = new( aTo )
            {{ struct_name_dyanamic}}(aObject);
    aTo += sizeof({{ struct_name_dyanamic}});

    aTo = impl::serialize_fields<{{ struct_name_dyanamic}},{{ struct_name }}>(aTo,
        aMaxSize - sizeof({{ struct_name_dyanamic}}), _head_ptr, aObject);
#ifndef NDEBUG
    if(aTo != NULL)
        DCHECK_EQ(get_full_size<{{ struct_name }}>(aObject), (aTo-_begin));
#endif
    fill_header<{{ struct_name_dyanamic}}>( _head_ptr );
    return aTo;
}
template<>
inline {{ struct_name }}& deserialize_binary<{{ struct_name }}>({{ struct_name }}& aTo,
    char const* aBegin, char const* aEnd)
{
    unsigned const _buf_size = aEnd-aBegin;
    unsigned const _size = {{ struct_name }}::SIZE_FULL;
    DCHECK_GE(_size, _buf_size);
    if(_size >= _buf_size)
    {
        {{ struct_name_dyanamic}} const& _val =
                *reinterpret_cast<{{ struct_name_dyanamic}} const*>(aBegin);
        _val.MTo(aTo);

        char const* _p = aBegin + _size;
        _p = impl::deserialize_fields<{{ struct_name_dyanamic}},{{ struct_name }}>(aTo, _val, _p);

        DCHECK_EQ(_buf_size, (_p-aBegin));
        DCHECK_EQ(_buf_size,get_full_size<{{ struct_name }}>(aTo));
    }
    return aTo;
}
{% endif %}
{% endmacro %}

{% for msg in messages  if '___type' in msg and msg.___type == 'dynamic' %}
    {%  if  '___parent' in msg and msg.___parent %}
        {% for ___parent in messages if ___parent.___number|string() == msg.___parent|string() %}
            {{ generate_serialize_message(msg,___parent) }}
        {% endfor %}
    {% else %}
        {{ generate_serialize_message(msg,header) }}
    {% endif %}
{% endfor %}

{% for msg in messages %}
    {% set struct_name =  msg.___name+'_t' %}
template<typename TContainer>
inline TContainer& operator<<(TContainer& aBuf,
		{{ struct_name }} const& aVal)
{
    return serialize_binary<TContainer, {{ struct_name }}>(aBuf, aVal);
}
template<typename TContainer>
inline TContainer& operator>>({{ struct_name }}& aVal,
		TContainer const& aBuf)
{
    return deserialize_binary<{{ struct_name }},TContainer>(aVal, aBuf);
}
{% endfor %}

}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}