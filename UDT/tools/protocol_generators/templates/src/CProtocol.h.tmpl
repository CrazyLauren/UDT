{%- import "base_macros.tmpl" as common %}
{%- import "./src/import_export_macros.h.tmpl" as export_file %}
{%- set file_name = 'CProtocol_' + name  %}
{{- common.add_file_secription(file_name+'.h',author,version) }}
{%- autoescape false %}

#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

#include <udt/udt_share_macros.h>
#include <udt/udt_types.h>
#include "{{ name | lower }}_import_export.h"

/*!\brief The class of object which is
 * implement a parser of {{ name }} protocol for the kernel
 *
 * As the kernel is used the plugin idiom  you has
 * to define the class which will added the
 * a parser. To pass configuration information
 * to library you has to be specified it
 * in the configuration file of kernel
 * in the key NUDT::CResources::NAME ->
 * NUDT::CResources::LIST_OF_LOADED_LIBRARY ->
 * "the library name" -> "you parameters...".
 * (with value passed to function #get_factory_registry)
 */

class {{ common.get_export_name(name) }} {{file_name}}:public NUDT::IExtParser
{
public:
	static NSHARE::CText const NAME;///< The unique name of protocol

	/*!\brief the default constructor
	 * in which you has to pass to IExtParser
	 * the unique protocol name
	 *
	 */
	{{file_name}}();

	/*!\brief default destructor
	 *
	 */
	virtual ~{{file_name}}();

	virtual result_t MParserData(const uint8_t* aItBegin,
			const uint8_t* aItEnd,NSHARE::uuid_t aFrom
            = NSHARE::uuid_t(),uint8_t aMask=NSHARE::E_SHARE_ENDIAN);
	virtual std::pair<NUDT::required_header_t,bool> MHeader(const NSHARE::CConfig& aFrom) const;
	virtual NSHARE::CConfig MToConfig(const NUDT::required_header_t&) const;

	virtual size_t MDataOffset(const NUDT::required_header_t& aHeader) const;
	virtual bool MSwapEndian(const NUDT::required_header_t& aHeader,
			uint8_t* aItBegin, uint8_t* aItEnd) const;
	bool MSwapEndian(NUDT::required_header_t* aHeader) const;
	inheritances_info_t MGetInheritances() const;
private:
};

#endif /* {{ file_name | upper }}_H */
{%- endautoescape %}