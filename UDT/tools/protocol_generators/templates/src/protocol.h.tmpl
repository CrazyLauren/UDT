{% set file_name = 'protocol_' + name | lower %}
{% import "base_macros.tmpl" as common %}
{% import "message_macros.tmpl" as fm %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape False %}
#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

#  include <{{ name | upper }}/config/config.h>

#ifdef HAVE_STDINT_H
#  include <stdint.h>
#endif
#include <string.h>

#include "{{ common.get_namespace(name) }}_attribute_packed.h"
{% set attribute_packed = name|upper+'_ATTRIBUTE_PACKED'%}

namespace {{ common.get_namespace(name) }}
{
/*! Returns unique protocol name
*
* Recommended using a short name.
*/
inline char const* protocol()
{
    return "{{ name }}";
}

/*!\brief A message numbers of {{ name }}
 *
 */
enum  eMessage
{
{% for msg in messages|sort(attribute='___number') %}  {{ msg.___name.rjust(20)|upper }} = {{ msg.___number }}, //!< {{ msg.___description }}
{% endfor %}
};

/*!\brief A user error number which is passed
 * to field NUDT::fail_sent_args_t::FUserCode
 *
 */
enum eParserError
{
	E_INVALID_HEADER_SIZE   = 1,//!< The message of header is invalid
	E_INVALID_MSG_SIZE      = 2,//!<The message size is invalid
	E_INVALID_MSG_TYPE      = 3,//!<The message type is invalid
	E_INVALID_MSG_CRC       = 4,//!<The message crc is invalid
};

/*! \brief Gets full size of message
 *
 * @param aVal The message
 * @return message full size
 * @tparam T message type
 */
template<class T>
inline unsigned get_full_size(T const & aVal );

namespace impl //implementation definitions
{
/*! \brief Gets size of dynamic data
 *
 * @param aVal Object
 * @return Size of dynamic data
 * @tparam T Object type
 */
template<class T>
inline unsigned get_full_size_dynamic(T const & aVal )
{
    return 0;
}
}//namespace impl

{% macro generate_message(aMsg, aParent) %}

{%  set struct_name =  aMsg.___name+'_t' %}
{%  set parent_name =  aParent.___name+'_t' if aParent else '' %}
{%  set paret_inherent =  ':'+parent_name if parent_name else '' %}
{%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
{%  set dynamic_parent_msg=true if parent_name and '___type' in aParent and aParent.___type == 'dynamic' %}
/*!\brief {{ aMsg.___description }}
 *
{% if dynamic_msg %}
 * @note serialized version is #{{ aMsg.___name }}_dynamic_t
{% endif %}
 */
{% if not dynamic_msg %}
{{ attribute_packed }}(
{% endif %}
struct {{ struct_name }}{{ paret_inherent }}
{
    {% if  parent_name %}
    typedef {{ parent_name }} parent_t;//!< parent type
    {% endif %}
    {% for field in aMsg | logical_type(["dynamic array"],True) %}
    typedef std::vector<{{field.DynamicType}}> {{field.id}}_dynamic_t;//!< array of {{field.id}}
    {% endfor %}
    {{- fm.add_constants(aMsg,aParent) }}

    {{- fm.append_fields(aMsg.___fields,["dynamic array"]) }}

    {%- if '___size' in  aMsg %}
        {{ fm.append_reserv(aMsg) }}
    {% endif %}

    {{- fm.add_functions(aMsg.___fields ,aParent) -}}

    {% for field in aMsg | logical_type(["dynamic array"],True) %}
    {{field.id}}_dynamic_t {{field.id}}; //!< {{ field.description }}
    {% endfor %}
{% if not dynamic_msg %}
	/*! @brief Zeroes object
	 *
     * The method is added as the POD object cannot have constructor.
	 */
    void makeZero()
    {
        memset(this, 0, sizeof(*this));
    }
{% endif %}
}
{% if not dynamic_msg %}
);
#if (__cplusplus>= 201103L) || (_MSC_VER >= 1800)
    static_assert(sizeof({{ struct_name }}) == {{ struct_name }}::SIZE_FULL,
                            "invalid size of message {{ aMsg.___name }}");
#elif defined(COMPILE_ASSERT)
    COMPILE_ASSERT(sizeof({{ struct_name }}) == {{ struct_name }}::SIZE_FULL,
        InvalidSizeOfMessage_{{ aMsg.___name }});
#endif
{% else %}
;
namespace impl{
/*! \brief Gets size of {{ aMsg.___name }} dynamic data
 *
 * @param aVal Object
 * @return Size of dynamic data
 * @tparam T Object type
 */
template<>
unsigned get_full_size_dynamic<{{ struct_name}}>({{ struct_name}} const & aVal )
{
    unsigned _size = 0;

    {% if dynamic_parent_msg %}
    _size += get_full_size_dynamic<{{ parent_name}}>(
            static_cast<{{ parent_name}} const&>(aVal)
            );
    {% endif %}

    {% for field in aMsg | logical_type(["dynamic array"],True) %}
    _size += sizeof({{ struct_name}}::{{field.id}}_dynamic_t::value_type)
            * aVal.{{field.id}}.size();
    {% endfor %}
    return _size;
}
}
{% endif %}
{% endmacro %}

{{ generate_message(header) }}

{% for msg in messages-%}
    {%  if  '___parent' in msg and msg.___parent
            -%}
        {% for ___parent in messages if ___parent.___number|string() == msg.___parent|string() -%}
            {{ generate_message(msg,___parent) }}
        {% endfor %}
    {% else %}
        {{ generate_message(msg,header) }}
    {% endif %}
{% endfor %}

template<class T>
unsigned get_full_size(T const & aVal )
{
    return T::SIZE_FULL + impl::get_full_size_dynamic<T>(aVal);
}
}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}
