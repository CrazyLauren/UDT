{% set file_name = 'protocol_' + name | lower + '_serialize' %}
{% import "base_macros.tmpl" as common %}
{% import "message_macros.tmpl" as fm %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape false %}

#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H


#include <{{ name | upper }}/config/config.h>
#include "{{ common.get_namespace(name) }}.h"
namespace NSHARE
{
    class aAllocator;
#ifndef SERIALIZE_TEMPLATE_IS_DEFINED
#  define SERIALIZE_TEMPLATE_IS_DEFINED

#  ifdef SHARE_CONFIG_DEFINED

/*! \brief Serialize type T
 *
 * The Serialized data key is equal "NAME".
 *
 * \param aObject Object
 * \return Serialized object
 * \tparam Serialized object type
 * \note  The method has to be specialized and "extern" for every external types.
 */
template<typename T>
inline NSHARE::CConfig serialize(T const& aObject);

/*! \brief Deserialize type T
 *
 * Deserialize object.
 *
 * @param aConf Serialized data (Child of key "NAME")
 * @return Deserialized object
 * @tparam Deserialized type
 * \note  The method has to be specialized and "extern" for every external types.
 * @{
 */
template<typename T>
inline T deserialize(NSHARE::CConfig const& aConf);
/*! @param aAllocator Used allocator of message */
template<typename T>
inline T deserialize(NSHARE::CConfig const& aConf,NSHARE::IAllocater* aAllocator)
{
	return deserialize<T>(aConf);
}
/*! @}*/
#  endif //# ifdef SHARE_CONFIG_DEFINED

#endif //#ifndef SERIALIZE_TEMPLATE_IS_DEFINED
}
namespace {{ common.get_namespace(name) }}
{
/*! \brief Checking if object of T is valid
 *
 * Usually It's using for validation deserialized object
 *
 * \param aObject Object
 * \return true - It's valid
 * \tparam Checked object type
 * \note  The method has to be specialized and "extern" for every external types.
 */
template<typename T>
inline bool is_valid(T const& aObject){
	return aObject.MIsValid();
}

/** \brief Return name
*/
template<typename T>
inline const char* get_name();

//
// Implementation
//

namespace impl{
template<class T>
inline bool deserialize_impl(T* aTo, NSHARE::CConfig const& aConf);

template<class T>
inline  T deserialize_from_json(char const* aVal)
{
    NSHARE::CConfig _tmp;
    bool const _is = _tmp.MFromJSON(aVal);
    DCHECK(_is);
    return  NSHARE::deserialize<T>(_tmp);
}
}
{% macro generate_serialize_functions(aMsg, aParentArray) %}

{% set aParent =  aParentArray[0] if aParentArray else None %}
{% set dynamic_msg = true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
{% set dynamic_parent_msg = true if parent_name and '___type' in aParent and aParent.___type == 'dynamic' %}
{% set struct_name =  aMsg.___name+'_t' %}
{% set parent_name =  aParent.___name+'_t' if aParent else ''  %}
{% set has_dynamic_child =  aMsg.___has_dynamic_child if '___has_dynamic_child' in aMsg else False %}


#ifdef SHARE_CONFIG_DEFINED
namespace impl{
/*! @brief Deserialize message of {{ aMsg.___name }}
*/
template<>
inline bool deserialize_impl<{{ struct_name }}>({{ struct_name }}* aTo,
    NSHARE::CConfig const& aConf)
{
    {% if parent_name %}
    deserialize_impl<{{ parent_name }}>(aTo, aConf);
    {% endif %}

    {% for field in aMsg.___fields|fields(True) %}
        {% if field.id %}
            {% set _is_dynamic_array = 'LogicalType' in field
                        and field.LogicalType|string() == "dynamic array" %}
{#            #}
            {% set _type =  field.TypeOfLogicalType if _is_dynamic_array else field.type %}
{#            #}
            {% set need_cast_to = field|castto( _is_dynamic_array) %}

            {% set _is_array = 'array_len' in field and field.array_len  > 0 %}

            {%if _is_array or _is_dynamic_array %}
    {
	    const NSHARE::ConfigSet& _child = aConf.MChildren("{{ field.id }}");
        {
             NSHARE::ConfigSet::const_iterator _it = _child.begin(), _it_end =
				    _child.end();
                {% if _is_dynamic_array %}
            aTo->{{ field.id }}.resize(_child.size());
            const std::size_t _array_size = _child.size();
                {% else %}
            const std::size_t _array_size = sizeof(aTo->{{ field.id }})/sizeof(aTo->{{ field.id }}[0]);
                {% endif %}

             std::size_t i=0;
             for (; i < _array_size&&//
                                _it != _it_end ; ++i,++_it)
                {% if need_cast_to %}
			        aTo->{{ field.id }}[i] = ({{ _type }})_it->MValue({{  need_cast_to }}());
                {% else %}
			        aTo->{{ field.id }}[i] = _it->MValue({{  _type }}());
                {% endif %}

            if( i < _array_size //
                || _it != _it_end
                )
            {
               LOG(DFATAL) << "The array {{ field.id }} length isn't equal " << _child.size()
                            <<" != "<<_array_size<<". Serialized data :"<< aConf.MToJSON(true);

                for (; i < _array_size; ++i)
                    aTo->{{ field.id }}[i] = {{ _type }}();
            }
	    }
    }
            {% else %}
    {
{#                {% if field.LogicalType|string() == "dynamic array"  %}#}
{#                    {% set static_cast_dynamic_to = 'int' if 'char'  == field.TypeOfLogicalType#}
{#                                        or 'uint8_t' == field.TypeOfLogicalType#}
{#                                        or 'int8_t' == field.TypeOfLogicalType#}
{#                                      else ''%}#}
{##}
{#                const NSHARE::ConfigSet& _child = aConf.MChildren("{{ field.id }}");#}
{##}
{#                aTo->{{ field.id }}.resize(_child.size());#}
{##}
{#                NSHARE::ConfigSet::const_iterator _it = _child.begin(),#}
{#                                                _it_end = _child.end();#}
{#                for (std::size_t i=0; i< _child.size() &&//#}
{#                                _it != _it_end ; ++i, ++_it)#}
{#                    {% if static_cast_dynamic_to %}#}
{#			        aTo->{{ field.id }}[i] = ({{ field.type }})_it->MValue({{  static_cast_dynamic_to }}());#}
{#                    {% else %}#}
{#			        aTo->{{ field.id }}[i] = _it->MValue({{  field.type }}());#}
{#                    {% endif %}#}
{##}
{#                {% else %}#}
                    {% if need_cast_to %}
            {{  need_cast_to }} _tmp_{{ field.id }};
                    {% else %}
            {{  field.type }} _tmp_{{ field.id }};
                    {% endif %}
            if(aConf.MGetIfSet("{{ field.id }}", _tmp_{{ field.id }} ))
            {
                aTo->{{ field.id }} = _tmp_{{ field.id }};
            }else
            {
                LOG(DFATAL) << "No value for {{ field.id }} in serialized data " << aConf.MToJSON(true);
            }

{#                {% endif %}#}

    }
            {% endif %}
        {% endif %}
    {% endfor %}

    return true;
}
}
}//namespace {{ common.get_namespace(name) }}
namespace NSHARE
{
template<>
inline {{ common.get_namespace(name) }}::{{ struct_name }}
    deserialize<{{ common.get_namespace(name) }}::{{ struct_name }}>(NSHARE::CConfig const& aConf)
{
    using namespace {{ common.get_namespace(name) }};
    {{ struct_name }} _tval;
    {% if not  dynamic_msg %}
    _tval.makeZero();
    {% endif %}
    {{ common.get_namespace(name) }}::impl::deserialize_impl<{{ struct_name }} >(&_tval, aConf);
	return _tval;
}

/*! @brief Serialize message of {{ aMsg.___name }}
*/
template<>
inline NSHARE::CConfig serialize({{ common.get_namespace(name) }}::{{ struct_name }} const& aObject)
{
    using namespace {{ common.get_namespace(name) }};
{% if parent_name %}
	NSHARE::CConfig _conf("{{ aMsg.___name }}", serialize<{{ parent_name }}>(aObject));
{%  else %}
    NSHARE::CConfig _conf("{{ aMsg.___name }}");
{% endif %}
    {{ fm.serialze_static_fields(aMsg) }}
    {% for field in aMsg.___fields|fields(True) %}
        {% if field.id %}
            {% if field.LogicalType|string() == "dynamic array"  %}
                {% set _dcast = field|castto(True) %}
                {% set need_cast_dynamic_to = '('+_dcast+')' if _dcast
                                      else '' %}
    for (std::size_t i = 0; i < aObject.{{ field.id }}.size(); ++i)
    {
	    _conf.MAdd("{{ field.id }}", {{ need_cast_dynamic_to }} aObject.{{ field.id }}[i]);
    }
            {% endif %}
        {% endif %}
    {% endfor %}
	return _conf;
}
}
namespace {{ common.get_namespace(name) }}
{
#endif //#ifdef SHARE_CONFIG_DEFINED
/*! @brief check is valid message
*/
template<>
inline bool is_valid<{{ struct_name }}>({{ struct_name }} const& aObject)
{
    {% if parent_name %}
    bool _is = is_valid<{{ parent_name }}>(aObject);
    {%  else %}
    bool _is = true;
    {% endif %}

    {% if '___constants' in aMsg %}
{#        {{ fm.validation_constants(aMsg) }}#}
        {% if '___parent' in aMsg %}
            {% for parent in aMsg.___parent %}
                {% set cur_parent_name_t =  parent.___name+'_t' %}
{#                {{ recursive_valid_impl(parent, aWhat) }}#}
                {% for pfield in parent.___fields|fields(True) %}
                    {% if 'LogicalType' in pfield
                            and pfield.LogicalType != 'none'
                            and 'LogicalTypeInfo' in pfield
                            and 'enum' in pfield.LogicalTypeInfo
                            and pfield.LogicalTypeInfo.enum | length >0
                            and
                            (
                                pfield.LogicalType == 'number'
                                or ('byprotocol' in aMsg.___constants
                                        and
                                        pfield.id in aMsg.___constants.byprotocol)
                                or (not has_dynamic_child and not dynamic_msg
                                      and pfield.LogicalType == 'size')
                            )
                            %}
    _is = _is && (false
                        {% for _enum in pfield.LogicalTypeInfo.enum %}
                || aObject.{{ pfield.id }} == {{_enum}}
                        {% endfor %}
    );
                    {% endif %}
                {% endfor %}
            {% endfor %}
        {% endif %}
    {% endif %}

    {% if not parent_name and '___constants' in aMsg %}
    {{ fm.validation_header_message(aMsg,messages) }}
    {% endif %}
    {% for field in aMsg.___fields|fields(True) %}
        {% set is_complex = ('TypeInfo' in field
                and not field.TypeInfo.standard
                and '___fields' in field.TypeInfo)
                or ('LogicalTypeInfo' in field
                and not field.LogicalTypeInfo.standard
                and '___fields' in field.LogicalTypeInfo)
                %}
        {% set is_limit = 'limitation' in field  %}

        {%if is_limit or is_complex %}
            {% if 'LogicalType' in field and field.LogicalType|string() == "dynamic array" %}
    std::size_t const {{ field.id }}_len=aObject.{{ field.id }}.size();
    for (std::size_t i = 0; i < {{ field.id }}_len; ++i)
    {
        {{ fm.check_field(field,True) }}
    }
            {% elif 'array_len' in field and field.array_len  > 0 %}
    for (std::size_t i = 0; i < sizeof(aObject.{{ field.id }})/sizeof(aObject.{{ field.id }}[0]); ++i)
    {
        {{ fm.check_field(field,True) }}
    }
            {% elif 'LogicalType' not in field or  field.LogicalType|string() == "none" %}
        {{ fm.check_field(field) }}
            {% endif %}

        {% endif %}
    {% endfor %}
    return _is;
}
template<>
inline const char* get_name<{{ struct_name }}>()
{
    return "{{ aMsg.___name }}";
}
{% endmacro %}

{% for val in types if not types[val].standard and '___fields' in  types[val] %}
{{ generate_serialize_functions(types[val]) }}
{% endfor %}


{{ generate_serialize_functions(header) }}

{% for msg in messages-%}
    {{ generate_serialize_functions(msg,msg.___parent) }}
{% endfor %}
}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}