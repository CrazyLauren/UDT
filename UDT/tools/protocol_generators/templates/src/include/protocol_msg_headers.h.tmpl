{% set file_name = 'protocol_' + name | lower + '_msg_headers' %}
{% import "base_macros.tmpl" as common %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape false %}

#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

# include <{{ name | upper }}/config/config.h>
#  ifdef HAVE_OFFSET_OF
#       include <cstddef>
#  endif
# include "{{ common.get_namespace(name) }}.h"

{% set struct_header_name =  header.___name+'_t' -%}
{% set field_crc = header.___LogicalType.crc[0] if 'crc' in header.___LogicalType else None%}
{% set size_field = header.___LogicalType.size[0] if 'size' in header.___LogicalType else None%}

namespace {{ common.get_namespace(name) }}
{
/*! Returns header of message
*
* return The Message header
*/
template <typename T>
inline {{ struct_header_name }} get_header_of();
template <typename T>
inline void get_header_of({{ struct_header_name }}* aTo);

/*! Fill header of message
*
* @param aTo the message
*/
template <typename T>
inline void fill_header(T* aTo);

/*! Copy only unique info from header
*
* @param aFrom aCopy info from
* @param aTo aCopy info to
*/
inline void copy_header({{ struct_header_name }}* aTo,{{ struct_header_name }} const* aFrom)
{
    {% for field in header.___fields|fields(True) %}
        {% if  field.LogicalType|string() in ["number","unique"] %}
    aTo->{{ field.id }} = aFrom->{{ field.id }};
        {% endif %}
    {% endfor %}
}
{% for msg in messages %}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg = true if '___type' in msg and msg.___type == 'dynamic' %}

/*! Returns header of message: {{ msg.___name }}
*
*
* return The Message header
*/
template <>
inline void get_header_of<{{ struct_name }}>({{ struct_header_name }}* aTo)
{
    {{ struct_header_name }}& _header(*aTo);
        {% for field in header.___fields|fields(True) %}
            {%  if  field.LogicalType|string() != "none" %}
                {% if field.LogicalType|string() == "number" and '___number' in msg %}
    _header.{{ field.id }} = {{ struct_name }}::NUMBER;
                {% elif field.LogicalType|string() in ["unique"]
                    and field.id in msg.___constants.byprotocol %}
                    {% set _val = msg.___constants.byprotocol[field.id] %}
                    {% if 'enumSource' in _val and _val.enumSource| length == 1 %}
    _header.{{ field.id }} = {{ struct_name }}::{{ field.id | upper }}_{{ (_val.enumSource|first).id | upper }};
                    {% endif %}
                {% endif %}
            {% endif %}
        {% endfor %}
}
{% endfor %}
}
    {% if field_crc  %}
        {% set crc_size = field_crc.TypeOfLogicalType.size | int if 'bits' not in field_crc
                    or field_crc.bits == 0 else  field_crc.bits // 8 %}
        {% set _polynom = field_crc.TypeOfLogicalType.polynom %}
        {% set _offset = field_crc.TypeOfLogicalType.crc_offset %}
        {% set _type_offset = field_crc.offset %}

        {% if crc_size |int() == 1 %}
#include <SHARE/crc8.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc8_t<{{ _polynom }},{{ _offset }}> protocol_crc_t;//!< Type of used CRC

        {% elif crc_size |int() == 2 %}
#include <SHARE/crc16.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc16_t<{{ _polynom }},{{ _offset }}> protocol_crc_t;//!< Type of used CRC
        {% elif crc_size |int() == 4 %}
#include <SHARE/crc32.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc32_t<{{ _polynom }},{{ _offset }}> protocol_crc_t;//!< Type of used CRC
        {% endif %}

    /** Calculate message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return CRC of data
    * @note Doesn't need to zeroize @ref {{ struct_header_name }}.{{ field_crc.id }}
    *    (CRC field) of message
    *
    */
    template<typename T>
    inline {{field_crc.type}} get_crc(void const* aData)
    {
        using namespace std;
        {{ struct_header_name }} const& _header=*reinterpret_cast<{{ struct_header_name }} const*>(aData);

        return protocol_crc_t::sMCalcCRCofBuf(
					(char*) aData,
{% if size_field %}
					(char*)aData + _header.getSize(),
{% else %}
					(char*)aData + sizeof(T),
{% endif %}
                    protocol_crc_t::Offset,
{% if 'bits' in field_crc and field_crc.bits > 0 and (field_crc.bits % 8) == 0 %}
                    {{ _type_offset//8 }}
{% else %}
#ifdef HAVE_OFFSET_OF
                    offsetof({{ struct_header_name }},{{ field_crc.id }})
#else
                    (unsigned)&((({{ struct_header_name }}*)0)->{{ field_crc.id }})
#endif
{% endif %}
            );
    }

    /** Sets message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return CRC of data
    *
    */
    template<typename T>
    inline {{field_crc.type}} set_crc(void* aData)
    {
        {{field_crc.type}} const _val=get_crc<T>(aData);
        {{ struct_header_name }} & _header=*reinterpret_cast<{{ struct_header_name }} *>(aData);

        _header.{{ field_crc.id }}=_val;
        return _header.getCRC();
    }

    /** Check for valid message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return true if valid
    * @note Doesn't need to zeroize @ref {{ struct_header_name }}.{{ field_crc.id }}
    *    (CRC field) of message
    *
    */
    template<typename T>
    inline bool is_crc_valid(void const* aData)
    {
        {{ struct_header_name }} const& _header=*reinterpret_cast<{{ struct_header_name }} const*>(aData);
        {{field_crc.type}} const _crc=get_crc<T>(aData);
        return _header.getCRC() == _crc;
    }
}
    {% endif %}

namespace {{ common.get_namespace(name) }}
{
template <typename T>
inline void fill_header(T* aTo)
{
    {% for field in header.___fields|fields(True) %}
        {%  if  field.LogicalType|string() != "none" %}
                {% if field.LogicalType|string() == "number" %}
    aTo->{{ field.id }} = T::NUMBER;
                {% elif field.LogicalType|string() == "size" %}
    aTo->{{ field.id }} = get_full_size<T>(*aTo);
                {% elif field.LogicalType|string() in ["version_major", "version_minor"]
                        %}
    aTo->{{ field.id }} = T::{{ field.id | upper }};
                {% endif %}
        {% endif %}
    {% endfor %}

    {% if field_crc%}
    if (T::HAS_DYNAMIC_FIELDS == 0)
        set_crc<T>(aTo);
    else
        aTo->{{ field_crc.id }} = 0;
    {% endif %}
}
template <typename T>
inline {{ struct_header_name }} get_header_of()
{
    {{ struct_header_name }} _header;
    _header.makeZero();
    get_header_of<T>(&_header);
    return _header;
}
}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}
