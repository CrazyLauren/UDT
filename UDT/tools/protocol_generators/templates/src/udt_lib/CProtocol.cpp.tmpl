// This is a personal academic project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
{% import "base_macros.tmpl" as common %}
{% set file_name = 'CProtocol_' + name  %}
{{ common.add_file_secription(file_name+'.cpp') }}
{% autoescape false %}
#define PROCESS_METHOD_NAME MProcess /*!< Define method which is used in
                                        * in "{{ common.get_namespace(name) }}_parser.h"
                                        * when returns result of buffer parsing
                                        *
                                        */
#define DOESNT_USE_OPERATOR
#define DOESNT_DESERIALIZE
#define FORCE_CALL_METHODS

#include <deftype>
#include <UDT/CParserFactory.h>

#include "{{ file_name + '.h' }}"
#include "{{ common.get_namespace(name) }}.h"
#include "{{ common.get_namespace(name) }}_swap_endian.h"
#include "{{ common.get_namespace(name) }}_msg_headers.h"
#include "{{ common.get_namespace(name) }}_ostream.h"
#include "{{ common.get_namespace(name) }}_serialize.h"
#include "{{ common.get_namespace(name) }}_serialize_binary.h"
#include "{{ common.get_namespace(name) }}_parser.h"
#include "{{ common.get_namespace(name) }}_udt.h"

{% set struct_header_name =  header.___name+'_t' %}
{% set field_size =header.___LogicalType.size[0]
        if 'size'in  header.___LogicalType else None  %}
{% set field_number = header.___LogicalType.number[0]
        if 'number'in  header.___LogicalType else None  %}
{% set field_crc = header.___LogicalType.crc[0]
        if 'crc'in  header.___LogicalType else None  %}
{% set field_version_major = header.___LogicalType.version_major[0]
        if 'version_major'in  header.___LogicalType else None  %}
{% set field_version_minor = header.___LogicalType.version_minor[0]
        if 'version_minor'in  header.___LogicalType else None  %}


using namespace NSHARE;
using namespace NUDT;
using namespace {{ common.get_namespace(name) }};

#ifndef NDEBUG
    COMPILE_ASSERT(sizeof({{ struct_header_name }}) <= sizeof(((required_header_t*)0)->FMessageHeader),
		INVALID_SIZEOF_HEADER);
#endif

NSHARE::CText const {{file_name}}::NAME = "{{ name }}";

{{file_name}}::{{file_name}}() :
		IExtParser(NAME)
{

}

{{file_name}}::~{{file_name}}()
{
}
size_t {{file_name}}::MDataOffset(const NUDT::required_header_t& aHeader) const
{
	/*! In the protocol the data is begun after header.*/
	return sizeof({{ struct_header_name }});
}
struct {{file_name}}::parser_impl
{
    result_t result;
    void PROCESS_METHOD_NAME({{ struct_header_name }} const* aHeader, bool,
            const char* aBegin, const char* aEnd, unsigned aNum)
    {
        if ( aNum != 0 )
            return;
        DLOG(INFO) << "Receive message #"<<aHeader->getNumber();
		obtained_dg_t _founded_dg;
		_founded_dg.FBegin = (const uint8_t*) aBegin;
        _founded_dg.FEnd = (const uint8_t*) aEnd;

        {{ struct_header_name }} const *_phead =
                        ({{ struct_header_name }} const*) aBegin;

{% if field_version_major %}
       _founded_dg.FType.FVersion.FMajor = _phead->{{ field_version_major.id }};
{% endif %}
{% if field_version_minor %}
       _founded_dg.FType.FVersion.FMinor = _phead->{{ field_version_minor.id }};
{% endif %}
        copy_header(({{ struct_header_name }}*)_founded_dg.FType.FMessageHeader,
                            _phead);
        result.push_back(_founded_dg);
    }
};
{{file_name}}::result_t {{file_name}}::MParserData(
		const uint8_t* aItBegin, const uint8_t* aItEnd,
    NSHARE::uuid_t aFrom,uint8_t aMask)
{
	parser_impl _parser;

    aItBegin = (uint8_t const*){{ common.get_namespace(name) }}::parser((char const*)aItBegin,
            (char const*)aItEnd,&_parser);

	return _parser.result;
}
std::pair<NUDT::required_header_t,bool> {{file_name}}::MHeader(
		const NSHARE::CConfig& aFrom) const
{
	/*! This is deserialization of the message header.*/

    using namespace std;

    {{ struct_header_name }} const _h(deserialize<{{ struct_header_name }}>(aFrom));

    bool const _is_valid = is_valid<>(_h);
    DCHECK(_is_valid);

	NUDT::required_header_t _header;
    const unsigned _min_size = min(sizeof(_header.FMessageHeader), sizeof(_h));

    memcpy(_header.FMessageHeader,&_h, _min_size);
	_header.FVersion = NSHARE::version_t(aFrom.MChild(NSHARE::version_t::NAME));

    return std::make_pair(_header, _is_valid);
}
NSHARE::CConfig {{file_name}}::MToConfig(
		const NUDT::required_header_t& aHeader) const
{
	/*! This is serialization  the message header.*/

    using namespace std;

    {{ struct_header_name }} _h;
    _h.makeZero();

    const unsigned _min_size = min(sizeof(aHeader.FMessageHeader), sizeof(_h));
    memcpy(&_h,aHeader.FMessageHeader, _min_size);

    DCHECK(is_valid<>(_h))<<_h;

	NSHARE::CConfig _conf(serialize<{{ struct_header_name }} >(_h));
    _conf.MAdd(aHeader.FVersion.MSerialize());
    return _conf;
}
NSHARE::CConfig {{file_name}}::MToConfig(const required_header_t& aHeader,
			const uint8_t* aItBegin, const uint8_t* aItEnd) const
{
	{{ struct_header_name }} const *_phead =
                        ({{ struct_header_name }} const*) aHeader.FMessageHeader;

    /*! This is serialization of the message.*/

    switch (_phead->getNumber())
    {
        {% for msg in messages%}
            {%  set struct_name =  msg.___name+'_t' %}
            {%  set dynamic_msg=true if '___type' in msg and msg.___type == 'dynamic' %}
            {%  set struct_dynamic_name = msg.___name+'_dynamic_t' if dynamic_msg else '' %}

        case {{ struct_name }}::NUMBER:
        {
            {% if not dynamic_msg %}
            {{ struct_name }} const *_t =
                ({{ struct_name }} const*) aItBegin;
            DCHECK(is_valid<>(*_t));
            return serialize<{{ struct_name }} >(*_t);
            {% else %}
#ifndef FORCE_DESERIALIZE
            {{ struct_dynamic_name }} const *_t =
                ({{ struct_dynamic_name }} const*) aItBegin;
            return serialize<{{ struct_dynamic_name }} >(*_t);
#else
            ///@todo need to optimize
            {{ struct_name }} _tmp;
            deserialize_binary<{{ struct_name }} >(_tmp,
                (char const*)aItBegin,
                (char const*)aItEnd);
            DCHECK(is_valid<>(_tmp));
            return serialize<{{ struct_name }} >(_tmp);
#endif
            {% endif %}
        }
            break;
        {% endfor %}

        default:
            break;
    }
    return NSHARE::CConfig ();
}
NSHARE::CBuffer {{file_name}}::MFromConfig(const NSHARE::CConfig& aFrom) const
{
    NSHARE::CBuffer _rval;
    {% for msg in messages %}
        {% set struct_name =  msg.___name+'_t' %}
        {% set _key_name = msg.___name %}
        {% if not loop.first %}
    else
        {% endif %}
    if(aFrom.MKey() == "{{ _key_name }}")
    {
        {{ struct_name }} const _val(deserialize<{{ struct_name }}>(aFrom));
        DCHECK(is_valid<>(_val));
        _rval<<_val;
    }
    {% endfor %}
{% if messages|length > 0 %}
    else
    {
        {{ struct_header_name }} const _h(deserialize<{{ struct_header_name }}>(aFrom));

        bool const _is_valid = is_valid<>(_h);
        DCHECK(_is_valid);
        if(_is_valid)
        {
            switch (_h.getNumber())
            {
    {% for msg in messages%}
        {%  set struct_name =  msg.___name+'_t' %}

                case {{ struct_name }}::NUMBER:
                {
                    {{ struct_name }} const _val(deserialize<{{ struct_name }}>(aFrom));
                    DCHECK(is_valid<>(_val));
                    _rval<<_val;
                }
                break;
    {% endfor %}
                default:
                    break;
            }
        }
    }
{% endif %}
    return _rval;
}
bool {{file_name}}::MSwapEndian(const NUDT::required_header_t& aHeader,
		uint8_t* aItBegin, uint8_t* aItEnd) const
{
    {{ struct_header_name }} const *_phead =
                            ({{ struct_header_name }} const*)( &aHeader.FMessageHeader);
    void *_p = (void*) aItBegin;
    bool _is = true;

 	switch (_phead->getNumber())
	{
{% for msg in messages%}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
    {%  set struct_dynamic_name = msg.___name+'_dynamic_t' if dynamic_msg else '' %}

        case {{ struct_name }}::NUMBER:
        {
{% if not dynamic_msg %}
            _is=_is && swap_endian_of(static_cast<{{ struct_name }}*>(_p));
{% else %}
            ///@todo create swap endian for dynamic data
{% endif %}
        }
        break;
{% endfor %}

        default:
            break;
    }
	return true;
}
bool {{file_name}}::MSwapEndian(NUDT::required_header_t* aHeader) const
{
	/*! You has to be defined method for swapping byte order
	 * of the header message.*/
    return swap_endian_of(({{ struct_header_name }}*)(aHeader->FMessageHeader));
}

{{file_name}}::inheritances_info_t {{file_name}}::MGetInheritances() const
{
	inheritances_info_t _info;
{% for msg in messages %}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  if  '___parent' in msg and msg.___parent %}
        {% set parent = msg.___parent | first %}
        {% if parent.___name !=  header.___name %}
            {%  set parent_name =  parent.___name+'_t' %}
        _info.push_back(
                        msg_inheritance_t( // {{ msg.___name }} inherent {{ parent.___name }}
                                required_header_t(get_header<{{ parent_name }}>()),//
                                required_header_t(get_header<{{ struct_name }}>())//
                            ));
        {% endif %}
    {% endif %}
{% endfor %}

	return _info;
}
int {{file_name}}::MDataSize (const required_header_t& aHeader) const
{
    using namespace std;
    {{ struct_header_name }} _h;
    _h.makeZero();

    const unsigned _min_size = min(sizeof(aHeader.FMessageHeader), sizeof(_h));
    memcpy(&_h,aHeader.FMessageHeader, _min_size);

	switch (_h.getNumber())
	{
{% for msg in messages%}

    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}

        case {{ struct_name }}::NUMBER:
        {
    {% if field_size %}
            return _h.getSize();
    {% elif not dynamic_msg %}
            return {{ struct_name }}::SIZE_FULL;
    {% else %}
            return -1;
    {% endif %}
        }
            break;
{% endfor %}

        default:
            break;
    }

    return -1;
}

REGISTRE_ONLY_ONE_PROTOCOL_MODULE({{file_name}},{{ name|upper }});

{% endautoescape %}