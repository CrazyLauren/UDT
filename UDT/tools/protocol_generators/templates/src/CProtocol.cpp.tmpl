// This is a personal academic project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
{% import "base_macros.tmpl" as common %}
{% set file_name = 'CProtocol_' + name  %}
{{ common.add_file_secription(file_name+'.cpp') }}
{% autoescape false %}

#include <deftype>
#include <udt/CParserFactory.h>

#include "{{ file_name + '.h' }}"
#include "{{ common.get_namespace(name) }}.h"
#include "{{ common.get_namespace(name) }}_swap_endian.h"
#include "{{ common.get_namespace(name) }}_msg_headers.h"
#include "{{ common.get_namespace(name) }}_ostream.h"
#include "{{ common.get_namespace(name) }}_serialize.h"
#include "{{ common.get_namespace(name) }}_serialize_binary.h"

{% set struct_header_name =  header.___name+'_t' %}
{% set field_size = header | logical_type('size') %}
{% set field_number = header | logical_type('number') %}
{% set field_crc = header | logical_type('crc') %}
{% set field_version_major = header | logical_type('version_major') %}
{% set field_version_minor = header | logical_type('version_minor') %}



using namespace NUDT;
using namespace {{ common.get_namespace(name) }};

COMPILE_ASSERT(sizeof({{ struct_header_name }}) <= sizeof(((required_header_t*)0)->FMessageHeader),
		INVALID_SIZEOF_HEADER);

NSHARE::CText const {{file_name}}::NAME = "{{ name }}";

{{file_name}}::{{file_name}}() :
		IExtParser(NAME)
{

}

{{file_name}}::~{{file_name}}()
{
}
size_t {{file_name}}::MDataOffset(const NUDT::required_header_t& aHeader) const
{
	/*! In the protocol the data is begun after header.*/
	return sizeof({{ struct_header_name }});
}
{{file_name}}::result_t {{file_name}}::MParserData(
		const uint8_t* aItBegin, const uint8_t* aItEnd,
    NSHARE::uuid_t aFrom,uint8_t aMask)
{
	using namespace std;
	/*! Algorithm of Parsing buffer from aItBegin to aItEnd:*/
	result_t _result;
    for (; aItBegin != aItEnd;)
	{
		bool  _buffer_is_small=false;
		const size_t _remain=aItEnd-aItBegin;
		obtained_dg_t _founded_dg;
		_founded_dg.FBegin = aItBegin;

		/*! If remain of buffer is less than the message header size
		 * wait for a new data.*/
		if (_remain < sizeof({{ struct_header_name }}))
			_buffer_is_small=true;
		else
		{
			/*! Compare the message type and size with predefined value of #eMessage.
			 *  If are equals then the message is founded.
			 *  In the other case the error #E_INVALID_MSG_TYPE or #E_INVALID_MSG_SIZE
			 *  is occured.
			 * */

			{{ struct_header_name }} const *_phead =
                        ({{ struct_header_name }} const*) aItBegin;
{% if field_version_major %}
            _founded_dg.FType.FVersion.FMajor = _phead->{{ field_version_major.id }};
{% endif %}
{% if field_version_minor %}
            _founded_dg.FType.FVersion.FMinor = _phead->{{ field_version_minor.id }};
{% endif %}
			switch (_phead->getNumber())
			{
            {% for msg in messages%}

                {%  set struct_name =  msg.___name+'_t' %}
                {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}

                case {{ struct_name }}::NUMBER:

                {% if field_size %}
                    {% if dynamic_msg %}
                    if (_phead->getSize() < sizeof({{ struct_name }}))
                    {% else %}
                    if (_phead->getSize() != sizeof({{ struct_name }}))
                    {% endif %}
				    {
					    aItBegin += sizeof({{ struct_header_name }});
					    _founded_dg.FErrorCode = E_INVALID_MSG_SIZE;
				    }
				    else  if (_remain < _phead->getSize())
					    _buffer_is_small = true;
                {% else %}
                    if (_remain < sizeof({{ struct_name }}))
					    _buffer_is_small = true;
                {% endif %}
                {% if field_crc %}
                    else if(!is_crc_valid<{{ struct_name }}>(aItBegin))
                    {
   					    aItBegin += sizeof({{ struct_header_name }});
					    _founded_dg.FErrorCode = E_INVALID_MSG_CRC;
                    }
                {% endif %}
				    else
				    {
                {% if field_size %}
					    aItBegin += _phead->getSize();
                {% else %}
					    aItBegin += sizeof({{ struct_name }});
                {% endif %}
                        copy_header(({{ struct_header_name }}*)_founded_dg.FType.FMessageHeader,
                            _phead);
				    }
                break;
            {% endfor %}

			default:
				aItBegin = aItEnd;
				_founded_dg.FErrorCode = E_INVALID_MSG_TYPE;
				break;
			}
		}

		if (_buffer_is_small)
			break;
		else
		{
			_founded_dg.FEnd = aItBegin;
			_result.push_back(_founded_dg);
		}
	}

	return _result;
}
std::pair<NUDT::required_header_t,bool> {{file_name}}::MHeader(
		const NSHARE::CConfig& aFrom) const
{
	/*! This is deserialization of the message header.*/

    using namespace std;

    {{ struct_header_name }} const _h(deserialize<{{ struct_header_name }}>(aFrom));

    bool const _is_valid = is_valid<>(_h);
    DCHECK(_is_valid);

	NUDT::required_header_t _header;
    const unsigned _min_size = min(sizeof(_header.FMessageHeader), sizeof(_h));

    memcpy(_header.FMessageHeader,&_h, _min_size);
	_header.FVersion = NSHARE::version_t(aFrom.MChild(NSHARE::version_t::NAME));

    return std::make_pair(_header, _is_valid);
}
NSHARE::CConfig {{file_name}}::MToConfig(
		const NUDT::required_header_t& aHeader) const
{
	/*! This is serialization  the message header.*/

    using namespace std;

    {{ struct_header_name }} _h;

    const unsigned _min_size = min(sizeof(aHeader.FMessageHeader), sizeof(_h));
    memcpy(&_h,aHeader.FMessageHeader, _min_size);

    DCHECK(is_valid<>(_h));

	NSHARE::CConfig _conf(serialize<{{ struct_header_name }} >(_h));
    _conf.MAdd(aHeader.FVersion.MSerialize());
    return _conf;
}
NSHARE::CConfig {{file_name}}::MToConfig(const required_header_t& aHeader,
			const uint8_t* aItBegin, const uint8_t* aItEnd) const
{
	{{ struct_header_name }} const *_phead =
                        ({{ struct_header_name }} const*) aItBegin;

    /*! This is serialization of the message.*/

    switch (_phead->getNumber())
    {
        {% for msg in messages%}
            {%  set struct_name =  msg.___name+'_t' %}
            {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
            {%  set struct_dynamic_name = msg.___name+'_dynamic_t' if dynamic_msg else '' %}

        case {{ struct_name }}::NUMBER:
        {
            {% if not dynamic_msg %}
            {{ struct_name }} const *_t =
                ({{ struct_name }} const*) aItBegin;
            DCHECK(is_valid<>(*_t));
            return serialize<{{ struct_name }} >(*_t);
            {% else %}
            ///@todo need to optimize
            {{ struct_name }} _tmp;
            deserialize_binary<{{ struct_name }} >(_tmp,
                (char const*)aItBegin,
                (char const*)aItEnd);
            DCHECK(is_valid<>(_tmp));
            return serialize<{{ struct_name }} >(_tmp);
            {% endif %}
        }
            break;
        {% endfor %}

        default:
            break;
    }
    return NSHARE::CConfig ();
}
NSHARE::CBuffer {{file_name}}::MFromConfig(const NSHARE::CConfig& aFrom) const
{
    NSHARE::CBuffer _rval;
    {{ struct_header_name }} const _h(deserialize<{{ struct_header_name }}>(aFrom));

    bool const _is_valid = is_valid<>(_h);
    DCHECK(_is_valid);
    if(_is_valid)
    {
 	    switch (_h.getNumber())
	    {
{% for msg in messages%}
    {%  set struct_name =  msg.___name+'_t' %}

            case {{ struct_name }}::NUMBER:
            {
                {{ struct_name }} const _val(deserialize<{{ struct_name }}>(aFrom));
                DCHECK(is_valid<>(_val));
                _rval<<_val;
            }
            break;
{% endfor %}
            default:
                break;
        }
    }
    return _rval;
}
bool {{file_name}}::MSwapEndian(const NUDT::required_header_t& aHeader,
		uint8_t* aItBegin, uint8_t* aItEnd) const
{
    {{ struct_header_name }} const *_phead =
                            ({{ struct_header_name }} const*)( &aHeader.FMessageHeader);
    void *_p = (void*) aItBegin;
    bool _is = true;

 	switch (_phead->getNumber())
	{
{% for msg in messages%}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}
    {%  set struct_dynamic_name = msg.___name+'_dynamic_t' if dynamic_msg else '' %}

        case {{ struct_name }}::NUMBER:
        {
{% if not dynamic_msg %}
            _is=_is && swap_endian_of(static_cast<{{ struct_name }}*>(_p));
{% else %}
            ///@todo create swap endian for dynamic data
{% endif %}
        }
        break;
{% endfor %}

        default:
            break;
    }
	return true;
}
bool {{file_name}}::MSwapEndian(NUDT::required_header_t* aHeader) const
{
	/*! You has to be defined method for swapping byte order
	 * of the header message.*/
    return swap_endian_of(({{ struct_header_name }}*)(aHeader->FMessageHeader));
}

{{file_name}}::inheritances_info_t {{file_name}}::MGetInheritances() const
{
	inheritances_info_t _info;
{% for msg in messages %}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  if  '___parent' in msg and msg.___parent %}
        {% for parent in messages if parent.___number|string() == msg.___parent|string() %}
            {%  set parent_name =  parent.___name+'_t' %}
        _info.push_back(
                        msg_inheritance_t( // {{ msg.___name }} inherent {{ parent.___name }}
                                required_header_t(get_header_of<{{ parent_name }}>()),//
                                required_header_t(get_header_of<{{ struct_name }}>())//
                            ));
        {% endfor %}
    {% endif %}
{% endfor %}

	return _info;
}
int {{file_name}}::MDataSize (const required_header_t& aHeader) const
{
    using namespace std;
    {{ struct_header_name }} _h;
    const unsigned _min_size = min(sizeof(aHeader.FMessageHeader), sizeof(_h));
    memcpy(&_h,aHeader.FMessageHeader, _min_size);

	switch (_h.getNumber())
	{
{% for msg in messages%}

    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg=true if '___type' in aMsg and aMsg.___type == 'dynamic' %}

        case {{ struct_name }}::NUMBER:
        {
    {% if field_size %}
            return _h.getSize();
    {% elif not dynamic_msg %}
            return {{ struct_name }}::SIZE_FULL;
    {% else %}
            return -1;
    {% endif %}
        }
            break;
{% endfor %}

        default:
            break;
    }

    return -1;
}

REGISTRE_ONLY_ONE_PROTOCOL_MODULE({{file_name}},{{ name|upper }});

{% endautoescape %}