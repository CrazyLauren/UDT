{% set file_name = 'protocol_' + name | lower + '_msg_headers' %}
{% import "base_macros.tmpl" as common %}
{{ common.add_file_secription(file_name+'.h',author,version) }}
{% autoescape false %}

#ifndef {{ file_name | upper }}_H
#define {{ file_name | upper }}_H

# include <{{ name | upper }}/config/config.h>
#  ifdef HAVE_OFFSET_OF
#       include <cstddef>
#  endif
# include "{{ common.get_namespace(name) }}.h"

{%  set struct_header_name =  header.___name+'_t' -%}

namespace {{ common.get_namespace(name) }}
{



/*! Returns header of message
*
* return The Message header
*/
template <typename T>
inline {{ struct_header_name }} get_header_of();

/*! Copy only unique info from header
*
* @param aFrom aCopy info from
* @param aTo aCopy info to
*/
inline void copy_header({{ struct_header_name }}* aTo,{{ struct_header_name }} const* aFrom)
{
    {% for field in header.___fields %}
        {% if  field.LogicalType|string() in ["number","unique"] %}
    aTo->{{ field.id }} = aFrom->{{ field.id }};
        {% endif %}
    {% endfor %}
}
{% for msg in messages %}
    {%  set struct_name =  msg.___name+'_t' %}
    {%  set dynamic_msg=true if '___type' in msg and msg.___type == 'dynamic' %}

/*! Returns header of message: {{ msg.___name }}
*
*
* return The Message header
*/
template <>
inline {{ struct_header_name }} get_header_of<{{ struct_name }}>()
{
    {{ struct_header_name }} _header;
    memset(&_header,0,sizeof(_header));

        {% for field in header.___fields %}
            {%  if  field.LogicalType|string() != "none" %}
                {% if field.LogicalType|string() == "number" and '___number' in msg %}
    _header.{{ field.id }} = {{ struct_name }}::NUMBER;
                {% elif field.LogicalType|string() in ["unique"]
                    and field.id in msg %}
    _header.{{ field.id }} = {{ struct_name }}::{{ field.id | upper }};
                {% endif %}
            {% endif %}
        {% endfor %}
    return _header;
}
{% endfor %}
}
{% set size_field = header |logical_type('size') %}
{% for field in header.___fields %}
    {% if field.LogicalType|string() == "crc" and field.bits == 0 %}
        {% set crc_size = field.type | type_info %}

        {% if crc_size.size |int() == 1 %}
#include <SHARE/crc8.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc8_t<{{ field.sampling|int() }},{{ field.min_value|int() }}> protocol_crc_t;//!< Type of used CRC

        {% elif crc_size.size |int() == 2 %}
#include <SHARE/crc16.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc16_t<{{ field.sampling|int() }},{{ field.min_value|int() }}> protocol_crc_t;//!< Type of used CRC
        {% elif crc_size.size |int() == 4 %}
#include <SHARE/crc32.h>
namespace {{ common.get_namespace(name) }}
{
    typedef NSHARE::crc32_t<{{ field.sampling|int() }},{{ field.min_value|int() }}> protocol_crc_t;//!< Type of used CRC
        {% endif %}

    /** Calculate message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return CRC of data
    * @note Doesn't need to zeroize @ref {{ struct_header_name }}.{{ field.id }}
    *    (CRC field) of message
    *
    */
    template<typename T>
    inline {{field.type}} get_crc(void const* aData)
    {
        using namespace std;
        {{ struct_header_name }} const& _header=*reinterpret_cast<{{ struct_header_name }} const*>(aData);

        return protocol_crc_t::sMCalcCRCofBuf(
					(char*) aData,
{% if size_field %}
					(char*)aData + _header.getSize(),
{% else %}
					(char*)aData + sizeof(T),
{% endif %}
                    protocol_crc_t::Offset,
#ifdef HAVE_OFFSET_OF
                    offsetof({{ struct_header_name }},{{ field.id }})
#else
                    (unsigned)&((({{ struct_header_name }}*)0)->{{ field.id }})
#endif
            );
    }

    /** Sets message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return CRC of data
    *
    */
    template<typename T>
    inline {{field.type}} set_crc(void* aData)
    {
        {{field.type}} const _val=get_crc<T>(aData);
        {{ struct_header_name }} & _header=*reinterpret_cast<{{ struct_header_name }} *>(aData);

        _header.{{ size_field.id }}=_val;
        return _header.getCRC();
    }

    /** Check for valid message CRC
    *
    * @param aData - Pointer to message
    * @tparam T - typeof message
    * @return true if valid
    * @note Doesn't need to zeroize @ref {{ struct_header_name }}.{{ field.id }}
    *    (CRC field) of message
    *
    */
    template<typename T>
    inline bool is_crc_valid(void const* aData)
    {
        {{ struct_header_name }} const& _header=*reinterpret_cast<{{ struct_header_name }} const*>(aData);
        {{field.type}} const _crc=get_crc<T>(aData);
        return _header.getCRC() == _crc;
    }
}
    {% endif %}
{% endfor %}
#endif /* {{ file_name | upper }}_H */
{% endautoescape %}
