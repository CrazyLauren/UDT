/**
@page  sysadmin_doc Information for sysadmin

@section com_info Common information
The UDT architecture is based on "daemon" pattern with extension plugins. The "daemon" is called \n
"Kernel". It realizes base functions and provides api for creating extensions.  The users program \n
communicates with the "Kernel" by using "customer" dynamic library.

@section communication Communication between "Kernel" and user's program
The "Kernel" uses two independent channels for communication. The first channel (service channel) is used \n
to transfer service info, the other (main channel) is used to transfer user's data. \n
The libraries "*io_manager" ("tcp_io_manager ") are realized services channels where * the type of
 channel. \n
The libraries "*main_channel" ("sm_main_channel") are realized main channels where * the type of
 channel. \n
In the current realize there is only one service channel - tcp and 3 main channels (UDP, SharedMemory (SM),\n
TCP). By historical reason the tcp main channel is used only for communication between Kernels. \n
The SM main channel is used only for  communication between Kernel and User's program.\n
To decrease amount of coping user's data in the SM channel is realized a smart multiprocess pointer. \n
Thus, the user's data isn't copping during transfer between programs. \n
Be careful, the user's program really uses common memory.

@subsection auto_search Auto connect
The kernel has plugin for looking for the other kernel by UDP multicast. Thus, You can \n
settup communication between "Kernel" by using iptables. The port is set in the configure file. \n
In the current realize "Kenel" "rhombic net" isn't supported.

@subsection set_com Manual setting communication
The communication settings is present in "Kernel" configure file.\n
For TCP you should setting tcp client and server, key in configure file "tcp" and "tcpser" correspondingly.\n
The key in configure file  for SM is "sm".\n
The setting description is present in default configure file. \n

@subsection protocol_info About protocol's
In the UDT for user is available two types of protocol: raw, user's. \n
The raw protocol is a inner protocol. \n
It have reserved id: "raw". According to the protocol messages are different \n
only by number. The message number is transmitted separately from the message "body". It can be \n
convenient to use binary protocol generators (protobuf). Some "kernel"  features isn't \n
available for the raw protocol as The "kernel" has  little information about the message, \n
for example: message structure. Thus The raw protocol usually is used for "quick starting" or\n
easy tasks.
The user's protocol is a outer (for "Kernel") protocol which is created by user.\n
In order to The "kernel" can use the user's protocol, user has to be create library which \n
realize user's protocol. The library can be generated by Kernel. See  @ref gen_protocol "Protocol generator".\n
But you can create it manually. As the "kernel" need to identify the messages all message of \n
user's protocol has to have unique id into the message. Also recommended to add version to the \n
message.

@subsection program_communication Communication principle
The data is exchanged between programs asynchronously  by publisher subscriber pattern. i.e \n
Senders of messages, called "PUBLISHERS",	are not have a program code of sending \n
the messages	directly to specific receivers, called "SUBSCRIBERS". \n
Instead of this, PUBLISHERS (Senders) categorize published messages \n
without knowledge of which	SUBSCRIBERS (Receivers). Similarly, SUBSCRIBERS \n
(Receivers) request (subscribes) one or more messages 	and receive only \n
those messages that are of want, without the knowledge of which PUBLISHER (Sender). \n
SUBSCRIBERS can request message from specific PUBLISHERS by it name or from specific group \n
of PUBLISHERS. \n
It is clear that physically the message is transmitted only if exists at least one SUBSCRIBER \n
to this message.
Of course, all rules have exception. In the UDT the program can send message directly \n
to only specified SUBSCRIBER (see API). Also The programs can be grouped (@ref program_id "Program
identification") \n
@subsection request Message request
SUBSCRIBERS request can be:
-		 non_unique_name 	- for receive message only from "non_unique_name"
-		 @group1.group2 	- for receive message from any program which is \n
		 					part of	group "group1.group2": for example \n
		 				   	rand@group1.group2.group3 \n
-		 name@group1		- for receive message only from "non_unique_name" \n
   		 					which is part of group "group1".
 \n
Also it can additionally manipulate of group\n
- invert group - the order@com.ru.putin is not enter \n
  	into the order@com.ru, but is enter into the order@com.ru.putin.vv
- receive from nearest - if there are next programs: \n
-- order@com.ru.people, \n
-- order@com.ru.putin.vv, \n
-- order@com.ru.kremlin, \n
than the order@com is included only order@com.ru.people and order@com.ru.kremlin \n
- logger mode - message will be delivered to receiver \n
only if there is at least one "non-registrator" (real) subscribed to the message.

@subsection errros Errors
If errors occurred during the data transfer, than an event EVENT_FAILED_SEND were occurs \n
in PUBLISHERS and SUBSCRIBERS. Its event is contained information about error and message	type. \n
@subsection swap Byte order
For convenience programmer, the message always is delivered in true byte order \n
(for user's protocol only!), whatever the byte  order of the message when it was sending.

@subsection version Message version control
In the UDT is realized message version control which is deny to receive the message if it \n
version isn't comparability with sent version.
The version is consist of two value: major, minor. The message is considered comparability if \n
major versions are equals, receiver's minor version is greater or equal sender's minor version.

@section program_id Program identification
The program have two different type of ID.\n
The first is an unique ID (UUID), which is generated \n
by "Kernel" on program start. It's different at every program start. It need to identification \n
several copy one program. To guarantee ID uniques You can specify part of it in the configure file.\n
\n
The second ID is program "class" identification. It's specified by user. This ID need to realize \n
user's logic for communication between programs (Who receive message and what ... ).\n
It can specified in the program source, \n
configure file or environment variable. Thus any program name is consists two part:
- non-unique name;
- groups. \n
It is defined as an utf8 string is made up of a lowercase  name ( Latin letters a to z, \n
digits 0 to 9, !#$%&'+-/=?^_`{|}~), an @ symbol, then a lowercase group \n
which is defined using a hierarchical naming pattern, with some levels in the hierarchy \n
separated by periods (."dot").  For example: \n
- non_unique_name@group1.group2.group3
- non_unique_name@com.google
- If no group: non_unique_name \n
The group is used for realize limits.
@section filters Filter of message
In the course of time the network becomes very large and difficult and thus amount of \n
transmitted "system" info increases. To decrease transmitted "system" info and \n
 duration of transient processes in the "Kernel" You can use filters.
The Filter is analogous to "iptables" on working principle. It ban all \n
@ref program_id "request" by rule, thus decrease amount of available messages.\n
Usually the difficult system consists of several modules. Thereby the filters sets for \n
every modules as most message transmitted into one modules.
The rule applies to only the kernel where it's defined.
@todo Add manual of filter rule and how it sets.

@section front_end Connect to exist program and device
By oneself the "Kernel" can connect to exist program. It's very usefully as you \n
doesn't need to develop program to communication. For example, if you need to receive data from device\n
by serial port, You only specify the protocol by using @ref gen_protocol "Protocol generator". \n
By oneself the "Kernel" will communicate with device and convert it to requirement format. \n
The communication with exist program setups in tag "frontend" of configure file. \n
@code
	"frontend":{
		"<interface type>": "<settings>",
		"name":" <name in UDT>",
		"rpl":"<name of exist protocol>",
		"mtu":"<mtu>",
		"onerror":"<type>",
		"repeat_time":"<repeat time>",
		"endian":"<received data endian>"
		"demand":[
			{
				"id":"from",
				"pl":"protocol",
				"num":"message number"
			}
		]
	}
@endcode
In the tag <interface type> contain information which is need to setup "physic" interface.
@subsection front_end_physic_interface Physic interfaces
<table>
<caption> Interfaces </caption>
<tr>    <th>Description </th>   <th> \<interface type\></th>   <th>Settings description </th> </tr>
<tr>    <td>TCP client </td> <td>tcp</td><td> <b>"port ":"< port>" \n
                                             "ip ":"< ip >" </b> \n
                                             "send_buf ":"maximum send buffer"\n
                                             "recv_buf ":"maximum receive buffer"\n
                                             "ka_time ":"Keep alive time"\n
                                             "ka_count ":"Keep alive count"\n
                                             "ka_on ":"true for enable keep alive"\n
                                             "buf_size_on ":"true to set buf size"\n
                                             "reuse_on ":"true to reuse port"
                                            </td></tr>
<tr>    <td>TCP server </td> <td>tcp</td><td><b> "port ":"<port>" </b>\n
                                             "send_buf ":"maximum send buffer"\n
                                             "recv_buf ":"maximum receive buffer"\n
                                             "ka_time ":"Keep alive time"\n
                                             "ka_count ":"Keep alive count"\n
                                             "ka_on ":"true for enable keep alive"\n
                                             "buf_size_on ":"true to set buf size"\n
                                             "reuse_on ":"true to reuse port"
                                            </td></tr>
<tr>
<td>PIPE (Server, Client)
        <sup>1</sup></td> <td>pipe_sever - for server \n
                            pipe - for client
                            </td> <td>
                                            For server: \n
                                                <b> "path ":"<path to 'file' for reading data>" </b>\n
                                                "client ":["<path to write 'file' for client 1 (read client 'file')>", \n
                                                            "<path to write 'file' for client 2>" \n
                                                 ] \n
                                            For client: \n
                                                "path ":"<path to 'file' for reading data (write 'file' server)>" \n
                                                <b> "server_path ":"<path to 'file' for writing data>"  </b>
                                            </td></tr>
<tr>
<td>Unix socket
            <sup>2</sup></td> <td>
                                    unix_dgram - for dgram
                                    </td> <td>
                                                 <b>"from":"<path to 'file' for reading data>" </b>\n
                                                "to":"<path to 'file' for writing data>"
                                            </td></tr>
<tr>
<td>Serial port</td> <td> rs232 \n
                          rs485 \n
                          rs422
                                    </td> <td>
                                                <b>"notation":"<8N1 or 7E1 or 7O1 or 7M1 or 7S1>", \n
                                                "speed":"<speed>",
                                                "path":"<path>"</b>
                                            </td></tr>
<tr>
<td>UDP</td> <td> udp
                    </td> <td>
                                               <b> "port":"<listen port>", </b>\n
                                                "type":"<unicast or broadcast or multicast>",
                                                not obligatory if specified "toip" \n
                                                "remove_invalid_send_ip":"<true of false>",
                                                 If set invalid send ip will be ignored \n
                                                "replace_full_broadcast_addr":"<true of false>"
                                                If set when full broadcast address 255.255.255.255
                                                    will replace to broadcast of
                                                    network interfaces \n
                                                "toip":[{ send data to ip\n
                                                    "port ":"<port>" \n
                                                    "ip ":"<ip>"\n
                                                    }]\n
                                                "fromip":[{ Receive data from if empty - from all\n
                                                    "port ":"<port>" \n
                                                    "ip ":"<ip>"\n
                                                    }]\n
                                             "send_buf ":"maximum send buffer"\n
                                             "recv_buf ":"maximum receive buffer"\n
                                             "buf_size_on ":"true to set buf size"\n
                                             "reuse_on ":"true to reuse port"
                                            </td></tr>
<tr>
<td>Read or write from (to) file
    <sup>3</sup></td> <td> file \n </td>
                                            <td>
                                            [{ \n
                                                <b>"direction": "<out or in>", </b>\n
                                                <b> "path" : "path to file", </b>\n
                                                "period" : "<period of sending data ( ms - integer) (for 'in' only)>" \n
                                                "size" : "<size of sending "message" (for 'out' only) >" \n
                                            }]
                                            </td></tr>
<tr>
<td>Loop (received data, will sent back
    )                   /td> <td> loop
                                    </td> <td>
                                                "max_speed":"<simulated channel speed>"
                                            </td></tr>
</table>
<sup>1</sup> Realization for windows and unix is differ.\n
<sup>2</sup> Only for unix system \n
<sup>3</sup> Interface can be one-directional or bidirectional \n

In the tag "<mtu>" contain information about mtu See @ref set_com "Mtu".\n
In the tag "<received data endian>" contain information about received data endian.\n
If it isn't set then the endian is equal of target computer endian. The value is\n
0 for Little endian\n
1 for Big endian\n

@subsection front_end_logical_interface Logical interfaces
In logical interface you settup behavior of external program in UDT.\n
The name of "exist" program is set in the tag "<name>". The name is specified on \n
common rules. \n
When Kernel receives the data from exists program it has to parse data to find messages.\n
Thus you should to specify the protocol id in the tag "<rpl>". If you dons't specify \n
protocol the data will published by 'raw' protocol. The message number will 1. \n
To send data to "exist" program you should specify subscription info. \n
To do this you can by specified tag "demand". \n
The tag is array. Every items are consists info about: \n
- from whom receive data (tag "id") see @ref request Subscription rule \n
- protocol name of data (tag "pl") \n

Further it will be more difficult: if you specified tag 'rh' - JSON object:\n

@code
{
    "id":"<from>",
    "pl":"<my protocol>",
    'rh':
    {
        "ver":
        {
            "major":"<val>",
            "minor":"<val>"
        },
        "buf":"< 8 byte in base64  >"
    }
}
@endcode

- tag "ver" - specified version of requirement message \n
- tag "buf" - specified message header in  byte ('raw') format (base64 code) \n
\n
    In the other case, to deserialize message header the method NUDT::IExtParser::MHeader  \n
of protocol parser library is used. The value of "<protocol name>" tag will be passed to the method \n
argument. \n
that is \n
@code
{
    "id":"<from>",
    "pl":"<my protocol>",
    "<my protocol>":{ // This object will be passed to NUDT::IExtParser::MHeader
    }
}
@endcode
That isn't all \n
If You use "raw" protocol (UDT inner protocol) then \n
@code
{
    "id":"<from>",
    "pl":"raw",
    "raw":{
        "num": "<message number>",
        "ver":
            {
                "major":"<val>",
                "minor":"<val>"
            }
    }
}
@endcode

All message are sent to physic interface sequentially. Thus while the message \n
doesn't transmitted, the other messages are buffered. If in during data transmission \n
the error is occurred, the kernel behaviour is defined by tag "onerror": \n
- "close" - close port
- "reopen" - reopen port
- "ignore" - ignore error
 \n By default is "ignore".

@section kernel_help Command line argument
To see list of available parameters call kernel with flag "-h"

*/
