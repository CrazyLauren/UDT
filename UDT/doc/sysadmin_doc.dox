/**
@page  sysadmin_doc Information for sysadmin

@section com_info Common information
The UDT architecture is based on "daemon" pattern with extension plugins. The "daemon" is called \n
"Kernel". It realizes base functions and provides api for creating extensions.  The users program \n
communicates with the "Kernel" by using "customer" dynamic library.

@section communication Communication between "Kernel" and user's program
The "Kernel" uses two independent channels for communication. The first channel (service channel) is used \n
to transfer service info, the other (main channel) is used to transfer user's data. \n
The libraries "*io_manager" ("tcp_io_manager ") are realized services channels where * the type of
 channel. \n
The libraries "*main_channel" ("sm_main_channel") are realized main channels where * the type of
 channel. \n
In the current realize there is only one service channel - tcp and 3 main channels (UDP, SharedMemory (SM),\n
TCP). By historical reason the tcp main channel is used only for communication between Kernels. \n
The SM main channel is used only for  communication between Kernel and User's program.\n
To decrease amount of coping user's data in the SM channel is realized a smart multiprocess pointer. \n
Thus, the user's data isn't copping during transfer between programs. \n
Be careful, the user's program really uses common memory.

@subsection auto_search Auto connect
The kernel has plugin for looking for the other kernel by UDP multicast. Thus, You can \n
settup communication between "Kernel" by using iptables. The port is set in the configure file. \n
In the current realize "Kenel" "rhombic net" isn't supported.

@subsection set_com Manual setting communication
The communication settings is present in "Kernel" configure file.\n
For TCP you should setting tcp client and server, key in configure file "tcp" and "tcpser" correspondingly.\n
The key in configure file  for SM is "sm".\n
The setting description is present in default configure file. \n
TODO description
Поскольку к «ядру» по одному и тому же порту могут подключаться как другие «ядра»,
так и «пользовательская библиотека», то в tcp_io_manager(tcp_client_io_manager),
 соответственно, существует параметр настройки протокола «protocol».
 Она сообщает ядру, какой протокол поддерживает порт. В текущей версии существует всего
  четыре протокола: "consumer", "udt_client","udt_server","http". "consumer
  " – «пользовательская библиотека»; "udt_client","udt_server" – client и server в «межъядерном» обмене данными;
  "http" – http сервер.

@subsection protocol_info About protocol's
In the UDT for user is available two types of protocol: raw, user's. \n
The raw protocol is a inner protocol. \n
It have reserved id: "raw". According to the protocol messages are different \n
only by number. The message number is transmitted separately from the message "body". It can be \n
convenient to use binary protocol generators (protobuf). Some "kernel"  features isn't \n
available for the raw protocol as The "kernel" has  little information about the message, \n
for example: message structure. Thus The raw protocol usually is used for "quick starting" or\n
easy tasks.
The user's protocol is a outer (for "Kernel") protocol which is created by user.\n
In order to The "kernel" can use the user's protocol, user has to be create library which \n
realize user's protocol. The library can be generated by Kernel. See  @ref gen_protocol "Protocol generator".\n
But you can create it manually. As the "kernel" need to identify the messages all message of \n
user's protocol has to have unique id into the message. Also recommended to add version to the \n
message.

@subsection program_communication Communication principle
The data is exchanged between programs asynchronously  by publisher subscriber pattern. i.e \n
Senders of messages, called "PUBLISHERS",	are not have a program code of sending \n
the messages	directly to specific receivers, called "SUBSCRIBERS". \n
Instead of this, PUBLISHERS (Senders) categorize published messages \n
without knowledge of which	SUBSCRIBERS (Receivers). Similarly, SUBSCRIBERS \n
(Receivers) request (subscribes) one or more messages 	and receive only \n
those messages that are of want, without the knowledge of which PUBLISHER (Sender). \n
SUBSCRIBERS can request message from specific PUBLISHERS by it name or from specific group \n
of PUBLISHERS. \n
It is clear that physically the message is transmitted only if exists at least one SUBSCRIBER \n
to this message.
Of course, all rules have exception. In the UDT the program can send message directly \n
to only specified SUBSCRIBER (see API). Also The programs can be grouped (@ref program_id "Program
identification") \n
@subsection request Message request
SUBSCRIBERS request can be:
-		 non_unique_name 	- for receive message only from "non_unique_name"
-		 @group1.group2 	- for receive message from any program which is \n
		 					part of	group "group1.group2": for example \n
		 				   	rand@group1.group2.group3 \n
-		 name@group1		- for receive message only from "non_unique_name" \n
   		 					which is part of group "group1".
 \n
Also it can additionally manipulate of group\n
- invert group - the order@com.ru.putin is not enter \n
  	into the order@com.ru, but is enter into the order@com.ru.putin.vv
- receive from nearest - if there are next programs: \n
-- order@com.ru.people, \n
-- order@com.ru.putin.vv, \n
-- order@com.ru.kremlin, \n
than the order@com is included only order@com.ru.people and order@com.ru.kremlin \n
- logger mode - message will be delivered to receiver \n
only if there is at least one "non-registrator" (real) subscribed to the message.

@subsection errros Errors
If errors occurred during the data transfer, than an event EVENT_FAILED_SEND were occurs \n
in PUBLISHERS and SUBSCRIBERS. Its event is contained information about error and message	type. \n
@subsection swap Byte order
For convenience programmer, the message always is delivered in true byte order \n
(for user's protocol only!), whatever the byte  order of the message when it was sending.

@subsection version Message version control
In the UDT is realized message version control which is deny to receive the message if it \n
version isn't comparability with sent version.
The version is consist of two value: major, minor. The message is considered comparability if \n
major versions are equals, receiver's minor version is greater or equal sender's minor version.

@section program_id Program identification
The program have two different type of ID.\n
The first is an unique ID (UUID), which is generated \n
by "Kernel" on program start. It's different at every program start. It need to identification \n
several copy one program. To guarantee ID uniques You can specify part of it in the configure file.\n
\n
The second ID is program "class" identification. It's specified by user. This ID need to realize \n
user's logic for communication between programs (Who receive message and what ... ).\n
It can specified in the program source, \n
configure file or environment variable. Thus any program name is consists two part:
- non-unique name;
- groups. \n
It is defined as an utf8 string is made up of a lowercase  name ( Latin letters a to z, \n
digits 0 to 9, !#$%&'+-/=?^_`{|}~), an @ symbol, then a lowercase group \n
which is defined using a hierarchical naming pattern, with some levels in the hierarchy \n
separated by periods (."dot").  For example: \n
- non_unique_name@group1.group2.group3
- non_unique_name@com.google
- If no group: non_unique_name \n
The group is used for realize limits.
@section filters Filter of message
In the course of time the network becomes very large and difficult and thus amount of \n
transmitted "system" info increases. To decrease transmitted "system" info and \n
 duration of transient processes in the "Kernel" You can use filters.
The Filter is analogous to "iptables" on working principle. It ban all \n
@ref program_id "request" by rule, thus decrease amount of available messages.\n
Usually the difficult system consists of several modules. Thereby the filters sets for \n
every modules as most message transmitted into one modules.
The rule applies to only the kernel where it's defined.
@todo Add manual of filter rule and how it sets.
@section front_end Connect to exist program and device
By oneself the "Kernel" can connect to exist program. It's very usefully as you \n
doesn't need to develop program to communication. For example, if you need to receive data from device\n
by serial port, You only specify the protocol by using @ref gen_protocol "Protocol generator". \n
By oneself the "Kernel" will communicate with device and convert it to requirement format. \n
The communication with exist program setups in tag "frontend" of configure file. \n
@code
	"frontend":{
		"<interface type>": "<settings>",
		"name":" <name in UDT>",
		"rpl":"<name of exist protocol>",
		"mtu":"<mtu>",
		"onerror":"<type>",
		"repeat_time":"<repeat time>"
		"demand":[
			{
				"f":"from",
				"pl":"protocol",
				"num":"message number"
			}
		]
	}
@endcode
In the tag "interface type" contain information which is need to setup "physic" interface.
<table>
<caption> Interfaces </caption>
<tr>    <th>Description </th>   <th> \<interface type\></th>   <th>Settings description </th> </tr>
<tr>    <td>TCP client </td> <td>tcp</td><td>"port ":"<port>" \n
                                             "ip ":"<ip table >"\n
                                             "send_buf ":"maximum send buffer"\n
                                             "recv_buf ":"maximum receive buffer"\n
                                             "ka_time ":"Keep alive time"\n
                                             "ka_count ":"Keep alive count"\n
                                             "ka_on ":"true for enable keep alive"\n
                                             "buf_size_on ":"true to set buf size"\n
                                             "reuse_on ":"true to reuse port"
                                            </td></tr>
<tr>    <td>TCP server </td> <td>tcpser</td><td>"port ":"<port>" \n
                                             "send_buf ":"maximum send buffer"\n
                                             "recv_buf ":"maximum receive buffer"\n
                                             "ka_time ":"Keep alive time"\n
                                             "ka_count ":"Keep alive count"\n
                                             "ka_on ":"true for enable keep alive"\n
                                             "buf_size_on ":"true to set buf size"\n
                                             "reuse_on ":"true to reuse port"
                                            </td></tr>
</table>
*/
