/**
@page  gen_protocol Protocol generator
The protocol generator is used to simplify working with binary protocols. \n
It can generate source code and protocol document corresponding to the source. \n
Of course, The protocol generator have GUI.
@section gen_protocol_req Requirements
@subsection gen_protocol_req_source To generate source code
The protocol generator can create source code and LaTeX (PDF) document of \n
protocol. \n
To create source code need only python with next modules \n
- jinja2
- ast

@subsection gen_protocol_req_doc To generate PDF document
The PDF documents is created from generated LaTeX file. There ara several ways to \n
generate PDF documents from LaTeX, below is described classical method for Windows OS. \n

For linux of course, the process is more easy, \n
as the all LaTeX packets you can install from repository. (If You don't what to read \n
list of requirements LaTeX modules,  install on the linux all latex modules by command \n
"apt install texlive-full" or "apt install texlive-latex-extra" .)

To create PDF document need LaTex instruments includes next modules:
- bytefield
- inputenc
- color
- babel
- geometry
- multirow
- tabularx
- longtable
- wrapfig
- graphicx
- makecell
- hyperref
- caption
- threeparttable
- placeins
- chngcntr
- titlesec
- indentfirst
- fancyhdr
- titletoc
- adjustbox

For linux you can install LaTeX from repository. \n
For windows you can or download all package (3.5 Gb) (TexLive CD) or \n
install packet manager (TexLive or MiKTeX) if You have internet. \n

@subsection gen_protocol_req_gui To working with GUI
To working with GUI You need only modern browser. \n
@warning For firefox after version 68.0 You need change "privacy.file_unique_origin" to false.
(To detail see internet) or also "python" need to use GUI (see below start GUI).


@section gen_protocol_general_info  Common information
@subsection gen_protocol_principle_work Principle to work
The process of generation source code is consist for several stage. \n
On the first stage the user by GUI generate protocol 'short description' -
simplify JSON file. \n
On the second stage, by python, from 'short description' generates \n
'full description' of protocol (uses protocol_schema.py).
On the next stage, by python, from 'full description' generates \n
source code (by Jinja2 module).
On the fourth stage, by python, from 'full description' generates \n
 'LaTeX description'  (latex_schema.py).
On the nest stage, by python, from 'LaTeX description' generates \n
LaTeX document (by Jinja2 module).
In the end, from LaTeX documents generates PDF and RTF document.

@subsection gen_protocol_principle_work_dir  Generator directories tree
The protocol generator is in 'protocol_generators' directory. \n
In the 'py' directory is python modules of the generator. \n
In the 'js' directory is javasripts modules of the GUI. \n
In the 'fonts' and 'css' directory is the GUI styles. \n
In the 'schemas' directory is JSON schema to validate input 'short description'. \n
In the 'templates' directory is files which is generated by 'Jinja2'. \n
<b> 'index.html' - main page of GUI </b>\n
<b> 'gen_protocol.py' - 'main' file of python modules </b>\n

@subsection gen_protocol_principle_gen_dir  Generated files description
The output generator files (> 20 ) description You can see in the generated PDF or LaTeX document. \n
The PDF document is in directory 'doc'.\n
Some main files: \n
- "protocol_*.h" -  C structures of the protocol
- "protocol_*_swap_endian.h" -  Function to swap endian of message
- "protocol_*_parser.h" -  Realize algorithm to handle received data of the protocol.

@subsection gen_protocol_quick_start How to use (Example)
1) Open in your browser <a href = "../../../../bin/protocol_generators/index.html"> GUI </a> \n
2) Press button 'Open protocol' \n
3) Select file 'EasyProtocol.json' (Example protocol)\n
4) Changes what you want \n
5) Press button 'Save protocol', and save it somewhere \n
6) Start \n
@code
    python <Path to UDT 'bin' directory>\protocol_generators\gen_protocol.py <Path to saved file> <Output directory>
@endcode
7) If no errors, you can see generated code in the 'Output directory'

@section gen_protocol_general_info  Protocol structure
The protocol structure is consist of:
- type of protocol message field;
- protocol message header (common part of all messages in the protocol);
- protocol messages data - the protocol message is "protocol message header" + "protocol messages data";
- info to generate protocol document (Authors, title, etc).

@subsection gen_protocol_quick_types Used types
There ara three type of types:\n
- enumerate - enumerate value;
- standard - C standard types;
- user types - user's defined types, which is constructed from enumerate types
    or standard types or the other user types.

For the standard and enumerate types You can specify the number of uses bits to create 'bit fields'.

@warning The generator automatically alignment types, be carefully then uses bit fields, If
You doesn't specified some bits, the generator interpret it as reserved bits.

The values in enumerate has to be different. \n
    For all types (Of course, with the exception of bit fields ) You can create the array.
There are two types of array: with static size and with dynamic size. \n
The array with static size doesn't have specified feature besides the array size, but the dynamic array has (see below). \n
The dynamic array can be created only in the protocol message. You cannot create it in user's type, \n
but the dynamic array of user's type can be created in the protocol message. In the user's type You can \n
create only array with static size.

@par About dynamic array

The elements of dynamic array are placed the end of the protocol message body. If you have several dynamic \n
array then it placed in the order specified by the 'DynamicOrder' (dynamic order) field.
If values of 'DynamicOrder' are equals then elements are placed in the defined order. \n
The dynamic array size is kept into the field with "dynamic array" logical type \n
(@ref gen_protocol_logical_type Logical types).  If the protocol message (child message) inherent the other \n
protocol message (base message) with dynamic array, then the dynamic arrays of base protocol message ara placed \n
in the end of the child protocol message. The first is the dynamic arrays of the base protocol message, \n
then the dynamic array of the child protocol message. The 'DynamicOrder' doesn't "merged" between child and \n
 base protocol message. That is if 'DynamicOrder' of the base protocol message dynamic array is '5' and \n
 'DynamicOrder' of the child protocol message dynamic array is '1', then The first dynamic array is with \n
 value '5' of 'DynamicOrder' as it in the base protocol message. To use the dynamic array the field with \n
 'size' local type is requirement to be into message header.  Also it's recommended to add the 'dynamic offset' \n
local type to the some field of the header (It can easiest to handle inherited message, as the end \n
of the child protocol message is differ from the base protocol message).\n
    The messages with 'dynamic array' has to serialize(deserialize) from the buffer. To do it the \n
'protocol_ * _serialize_binary.h' is used. As operation serialize(deserialize) is reduce \n
the performance, It doesn't create for messages without 'dynamic array'.   Thus \n
the protocol message is be two types: <b> "dynamic" - can have 'dynamic array' and \n
 "static" - cannot have 'dynamic array' </b>.\n
For the protocol dynamic message, also the structure with '_dynamic_t' prefix is created. It's used \n
 to work with 'serialized' protocol dynamic message. The structure without the prefix has \n
 'dynamic array'. Also if You use UDT is recommended to work with optimized for UDT structures. \n

If base message is "dynamic" then all its children has to be "dynamic" too. \n
The dynamic array value type is specified in to 'TypeOfLogicalType'.

@warning If you don't use 'dynamic array', don't set "dynamic" type of message!
@subsection gen_protocol_header Protocol message header
Usually the protocol message header contains information to identification the protocol messages. \n
In the protocol message header You can specify:
- message number (has to be unique for each message);
- checksum;
- version of message (major, minor);
- size of message.
The message header can consist field of any type with the exception the dynamic array. \n
The message number has to be only integer value (unsigned of signed :) ).\n
The message checksum type has to be alignment in the header (that is the first bit of type which is kept CRC16 \n
  has to be multiple to 16).

@subsection gen_protocol_logical_type Logical types of the field
Of course, to create the protocol buffer parser (realize algorithm to search message in "random" data buffer) \n
need to know: Into what is the field consist the message \n
unique number? Is there checksum in the protocol? etc. \n
The logical type value of field is used to To answer to this question. The logical types which is used \n
in generator You can see below
<table>
<caption> Logical types </caption>
<tr><th>Name </th>   <th> Description</th>  </tr>
<tr> <td> none </td> <td> Ordinary field </td> </tr>
<tr> <td> number </td> <td> Into this field message number \n
                            (has to be one).<b> The Minimal message number is 1.</b></td> </tr>
<tr> <td> unique </td> <td> This field is used to identification \n
                            the message besides the number. \n
                            In other words, the messages with equal number \n
                            but with different unique value is interpret as \n
                            different messages in the UDT (It's subtype of message). \n
                            Usually The unique value is enumerate
                             </td> </tr>
<tr> <td> size </td> <td> Message full size \n
                    (requirement if You use dynamic array)</td> </tr>
<tr> <td> version_major </td> <td> The major version of message \n
                                    If major version of message is different then \n
                                    they aren't comparability
    </td> </tr>
<tr> <td> version_minor </td> <td>The minor version of message \n
                                If minor version of message is greater
                                or equal to the other then \n
                                they are comparability.</td> </tr>
<tr> <td> crc </td> <td> The checksum of the message.\n
                         The crc type (size) is equal of type size (8, 16, 32).\n
                         Warning in the current version, \n
                         the crc type cannot in th 'bit fields' (Alignment protection).
                        </td> </tr>
<tr> <td> dynamic array </td> <td> It's size of dynamic array.</td> </tr>
<tr> <td> dynamic offset </td> <td> The begin of dynamic arrays.</td> </tr>
<tr> <td> enum </td> <td> </td> It's enumerate type</tr>
</table>
If there are "number", "unique", "version_major" or "version_minor" logical type in the field \n
then for the all message has to be specified the value of the field. \n
The field with "unique" logical type should be enumerate type (@ref gen_protocol_general_info Enumerate type).

@subsection gen_protocol_type_limitation Limitation of the field value
You can specify limits to the value of field. The limit is defined in next format \n
@code
    [<, >, >=, <=, == , != ] [some value] [, ... ]
@endcode
    where 'some value' number(integer or float) or json string (for field with user's type). \n
For example:
@code
    = 5
    > 5, != 10, <= 12
    = {'some_value':'5'}
@endcode
@subsection gen_protocol_type_crc Message checksum
You can specify checksum of the protocol message. The crc type (polynom size) is equal of type size (8, 16, 32) \n
The CRC polynom is specified in the 'sampling' value. If You want to specify the offset for CRC, then \n
in the limitation write '= < offset value>', < offset value> - requirement offset value.

@subsection gen_protocol_inherent Message inheritance
The protocol message (child message) can inherent the other protocol message (base message). (In the UDT You can inherent also \n
the message from another protocol, in the generator with option has't be implemented yet.)\n
To do it specify the number of the inherited message, then the data of child message will be putted to \n
the end of the base message.
@subsection gen_protocol_identification Types identifier
To avoid conflict of service identifier and user's identifier. To user's identifier It's added prefix or postfix. \n
Also doesn't recommended to use 'standard' identifier, for example: 'size', 'number', 'offset' ... \n
The next ID (with prefix and postfix which is described upper) has not to be equal in the protocol \n
- the enumerate type ID;
- the all value ID of the enumerate type;
- user's type ID;
- standard type ID;
- message ID;
- message header ID.
@subsection gen_protocol_doc Info to generate protocol document
To generate correct protocol document need specify next info:
- Title of the document, messages, user's types ...;
- Authors of the document;
- Version of the document;
- Organization which is developed protocol;
- License (can be empty);
- Description of the document, messages, user's types ...;
- Units of measurement.

@par About "Title"
The title is used as header or short description. Doesn't recommended to use large \n
title as it can come out from page. The title of the document can be write in several row. \n
To force go to the next row write '\\\\' symbols.

@par About "Descriptions"
The description is passed after title. Usually it consists detailed info.
All 'Descriptions' is LaTeX code. Thus you can create tables, insert image ... by using LaTeX. But some symbols \n
has to be escaped.
<table>
<caption> Reserved LaTeX characters </caption>
<tr><th> Character </th>   <th> How to write it</th> </tr>
<tr><td> '\\' </td>   <td> '$\\backslash$' </td>  </tr>
<tr><td> '$' </td>   <td> '\\$' </td>  </tr>
<tr><td> '\%' </td>   <td> '\\\%' </td>  </tr>
<tr><td> '&' </td>   <td> '\\&' </td>  </tr>
<tr><td> '^' </td>   <td> '\\^' </td>  </tr>
<tr><td> '{' </td>   <td> '\\{' </td>  </tr>
<tr><td> '}' </td>   <td> '\\}' </td>  </tr>
<tr><td> '~' </td>   <td> '\\~' </td>  </tr>
<tr><td> '_' </td>   <td> '\\_' </td>  </tr>
</table>
The generated text is usually inserted after "Descriptions".

@par About "Version" of document
The version of document is inserted in the title page, after title of the document.

@par About "Authors" and "Organization"
The generator creates an signature field. To do it The generator need to know organization, person name \n
post, and what is kind of signature generate and where?
Before You need fill info about organization, than adds all person to document. \n
To answer to question upper, fill 'executor' info (See table below).
<table>
 <caption> "executor" field acceptable value </caption>
 <tr><th> acceptable value </th>   <th> What is do?</th> </tr>
 <tr><td> asserting that </td>   <td> Generates signature in the top right angle
                                        the document title. It sas to be only one.
                                        The text "ASSERTING THAT" under signature is placed.
                                         </td>  </tr>
<tr><td> matching </td>   <td> Generates signatures in the right
                                page side below the document title.
                                The text "MATCHING" under signature is placed.
                                         </td>  </tr>
<tr><td> executor </td>   <td> Generates signatures in the end of the document
                                in the columns by organization.
                                         </td>  </tr>
</table>
@par Byte order and language
The message byte order and language is set in the settings.
@par About result
The result of generation You can see in the "doc" subdirectory. If you install LaTeX then the pdf file is created.\n
The LaTeX document (*.tex) is generated always. If you don't install LaTeX, you can generate rtf, doc (maybe!) \n
 or pdf document manually from LaTeX document (to detail see internet).
@section gen_protocol_gui GUI
@subsection gen_protocol_gui_start Start GUI
The GUI can be started in the two mode: as http server or local. To start in the local mode open in the browser \n
the 'index.html' file (for firefox after version 68.0 You need change "privacy.file_unique_origin" to false). \n
To start as "python" server write in command line:
@code
python -m http.server
@endcode
In the directory with the 'index.html' file. And in the browser open page:
@code
127.0.0.1:8000
@endcode

@subsection gen_protocol_gui_how_to How to work with GUI
In general the GUI is very easy and is corresponding to protocol structure. \n
To load exist protocol press button 'open', to save protocol file which is passed to python script press button 'save'. \n
If created isn't valid you see the corresponding label. (Realized is not all check) \n
The language You can select in setting tab.  To see (change) raw JSON file press button 'JSON'. \n
@warning if you choose parent message and it in the table after the child message then the selected value can disappear.

The GUI and source code generated by different code therefore to see real generated code view protocol document.\n
The GUI is refreshed automatically but sometime it cannot to do it. Press button "refresh" to force refresh.

@section gen_protocol_source Generated source code
@subsection gen_protocol_source_build How to build
If You doesn't use the UDT, then you doesn't need to build source. You can copy requirement files from \n
'src' directory. In other case, you need build source to create library which is handle this protocol.\n
To do it, you need install CMake and UDT (of course). The instruction of build is similar to instruction for UDT (see Install.md) \n
with one exception. You should specify "CMAKE_INSTALL_PREFIX" to UDT install directory (no UDT binary!). That is \n
"<CMAKE_INSTALL_PREFIX>\bin\Kernel". Also need specify path to "boost" library directory. (For linux you can install \n
libboost-dev packet, than path is founded automatically). Now then You make install operation. library is installed \n
automatically in the right directory. \n
The protocol structures is defined in 'protocol_*.h' file.

@warning The library is installed into two place: default library directory and "plugin" Kernel subdirectory of binary directory.
@subsection gen_protocol_source_use The protocol parser
The protocol parser need for looking for the messages in the "random" byte buffer. It is created for C++03 standard \n
 (for more compatibility) and realized in 'protocol_*_parser.h' file.
@par How to work
It's base on C+++ template. The function for parsing the buffer is called as 'parser'.
The first and second argument of the function is pointer to handled buffer (analogous std::begin std::end). \n
The third argument is pointer to object (<b>user's handler</b>) which will handle searched messages.
@par How is it working
Then the function parser is founded the message header \n
it try to found in the object user's handler operator() one of next signature.
@code
/* Handler method(operator)
* @param aMsg - handled message or message header
* @param aIsInherent - true if is called as received child message, false if is received own message
* @param aBegin - The begin of data in the buffer
* @param aEnd - The end of data in the buffer
* @param aNum - The sequence number of the handler for this message (If message have parents, then the parent
message handler also is called)
*/
void (<A type> const* aMsg,bool aIsInherent,char const* aBegin,char const* aEnd, unsigned aNum) const;
void (<A type> const* aMsg,bool aIsInherent,char const* aBegin,char const* aEnd, unsigned aNum) ;
@endcode
or functions with the equal signatures which the name is defined by PROCESS_METHOD_NAME macro. \n
(which is can handle the message header).\n
If it's founded, then it call the method or operator. \n
Similar, if it's founded method or operator to handle the message (first argument of function is message type), \n
It deserialize the message(for dynamic only) and call method or operator. \n
If the message have parents messages, then method of parent handler are called too. \n
The latest always is called own message handler.
The logical of handling errors are similar. The method (defined by ERROR_METHOD_NAME) or operator with next \n
signature is called.
@code
/* Error handler
* @param eError - Type of error
* @param aBegin - Where error is occured
* @param aEnd - The end of the buffer
* @return The pointer to the next byte which the parser has to handle
*/
char const* (eParserError const& eError,char const* aBegin,char const* aEnd) const;
@endcode
If it's not defined then the error is handled on default.
@par Macro settings
<table>
 <caption> Macros </caption>
 <tr><th> macro </th>   <th> What is do?</th> </tr>
 <tr><td> PROCESS_METHOD_NAME </td>   <td> If defined then
                                            the macro value is a method name
                                            which is used by parser for
                                            search appropriate function
                                            signature in the class to handle message.
                                            (Besides operator())
                                         </td>  </tr>
<tr><td>FORCE_CALL_METHODS</td>   <td> Doesn't search appropriate method(operator) in the class.
                                        (Disable searching template magic)
                                         </td>  </tr>
<tr><td> DOESNT_USE_OPERATOR </td>   <td> Doesn't search appropriate operator in the class.
                                         </td>  </tr>
<tr><td> ERROR_METHOD_NAME </td>   <td> If defined then
                                        the macro value is a method name
                                        which is used by parser for
                                        search appropriate function
                                        signature to handle error
                                        in the class.
                                        (Besides operator())
                                         </td>  </tr>
<tr><td> DOESNT_DESERIALIZE </td>   <td> Disable deserialize dynamic message.
                                         (pass to handle function *_dynamic_t structure)
                                         </td>  </tr>
</table>
@subsection gen_protocol_source_serialize Serialize to JSON (XML) (protocol_*_serialize.h)
To serialize (deserialize) from JSON(XML) The CConfig class of SHARE is used. \n
To deserialize, on the first step, the CConfig reads data from JSON(XML) and creates "property tree".\n
Than "property tree" is used template function NSHARE::deserialize to create object.\n
To serialize, on the first step, template function NSHARE::serialize is create "property tree" of CConfig. \n
Than the "property tree" is writing to JSON(XML) file.\n
Also the generator creates function to validate the messages. It's based on info about <b>limitation</b>. \n
The function signature is
@code
some_struct_t _value;
NSHARE::CConfig const _serialized(NSHARE::serialize(_value));

std:ofstream _file_json('test.json');
std:ofstream _file_xml('test.json');

_serialized.MToJSON(_file);
_serialized.MToXML(_file_xml);

int _des_value(NSHARE::deserialize<some_struct_t>(_serialized));
std::cout<<is_valid(_des_value) <<std::endl;

@endcode
To detail You can see in generated test file (serialize_test*);
@subsection gen_protocol_source_swap Swap message endianness (protocol_*_swap_endian.h)
To change message byte order (LITTLE, BIG) You can use 'swap_endian_of' function.
@code
template <typename T>
inline  bool swap_endian_of(T* aTo);
@endcode
@subsection gen_protocol_source_standard C++ standard operation
The generator overload for messages:
- 'operator<<' for ostream (file protocol_*_ostream.h)
- for c++11:  'operator<<' and 'operator>>' for 'byte buffers' (for example std::vector<char>) (file protocol_*_serialize_binary.h)
- compare operator: <. <=, ==, !=, >=, >. (file protocol_*_compare_operators.h)
@subsection gen_protocol_source_header Auto fill message header
If you have CRC in message header or several constants You can use 'fill_header' function \n
 (protocol_*_msg_headers_endian.h).

*/